#+TITLE: #+TITLE: What's Ap with zio-prelude?
#+AUTHOR: Justin Heyes-Jones
#+DATE: 2020
#+STARTUP: showall
#+OPTIONS: toc:nil
#+HTML_HTML5_FANCY:
#+CREATOR: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.3 (<a href="http://orgmode.org">Org</a> mode 9.4)
#+BEGIN_EXPORT html
---
layout: post
title: What's Ap with zio-prelude?
date: '2020-08-02T00:00:00.000-08:00'
tags: [pure-functional-programming, cats, scala, applicative, monads, functors, zio]
---
#+END_EXPORT

** Introduction
Back in April I did a deep dive into ~Applicative Functors~ and produced a
lengthy blog post that explains the practical use of Applicatives in Scala, how
they are implemented and where these ideas came from. If you are not familiar
with functional programming in Scala using Cats, and the Applicative type class
in particular, I'd recommend at least scanning the post below or checking out
one of the related talks in the links above.

#+BEGIN_EXPORT html
<a href="/2020/04/04/whats-ap.html">What's Ap?</a>
#+END_EXPORT

It can be challenging to explain the implementation of Applicative in Scala, and
especially the ~ap~ operation itself, which as the following tweet points out,
relies on currying to do its work. You can see this in some of the example code
in my post where I translated Haskell from the original 2008 paper "Applicative
Programming with Effects" into Scala. The lack of implied currying in Scala makes
working with applicatives involve a bit more typing than in Haskell, and
operates in a way that many Scala programmers will not be familiar with.

#+BEGIN_EXPORT html
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">For a decade, &#39;ap&#39; from Applicative has infected Scala code:<br><br>def ap[A, B](f: F[A =&gt; B], fa: F[A]): F[B]<br><br>Cryptic &amp; confusing, did you know the raison d&#39;Ãªtre of &#39;ap&#39; is Haskell&#39;s curried functions, not category theory?<br><br>Learn how we can do better! ðŸ‘‡<a href="https://t.co/IL2FnBbPOy">https://t.co/IL2FnBbPOy</a></p>&mdash; John A De Goes (@jdegoes) <a href="https://twitter.com/jdegoes/status/1288134300349718530?ref_src=twsrc%5Etfw">July 28, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
#+END_EXPORT

Currying, although not used as often in Scala as Haskell, as an important part
of the language, and Scala programmers should probably become familiar with it.

https://docs.scala-lang.org/tour/multiple-parameter-lists.html

Is this criticism fair? In this post we'll check out the new type class encoding
that you will find in the new functional programming library ~Zio-Prelude~, and
compare it with the established encoding and hierarchy that you will find in
Cats, and that was closely modelled on Haskell.

https://github.com/zio/zio-prelude

** zio-prelude in a nutshell
I've only been aware of prelude for a couple of days, so I'm not an expert by
any means. What I have learned so far is based on a recent talk at SF Scala for
which you can find the slides here:

https://www.slideshare.net/jdegoes/refactoring-functional-type-classes

Unlike Scalaz and Cats, prelude was not initially a public project, and was
developed as part of John De Goes' ongoing functional programming classes.
However it is now fully open sourced and the Scala community as a whole can take
part in the project.

As you'll see in the slide deck, the goals of prelude are the following:

- Radical
- Orthogonal
- Principled
- Scala-First
- Minimal
- Pragmatic
- Accessible
- Opinionated

The goals I find most compelling here are accessible and orthogonal. As an fp
advocate and educator, I am very interested in any steps towards greater
accessibility. The orthogonal part is also big, as I believe that composability is
one of the biggest wins of pure functional programs.

** Algebra not Category Theory
With Cats, almost all of the concepts come from category theory. We have Monads,
Functors, Monoids, Monoidal Functors and so on. The idea with prelude is that
algebra is more familiar to us, as non-mathematician programmers, than category
theory. Algebra's are also more composable, so the idea is to start with a small
number of primitive things(?) and combining them into more powerful objects.

The big question that prelude puts out there is this; is Category Theory an
obstacle to adoption of pure functional programming, and would abstract algebra
be a better way to both introduce newcomers, and provide a better solution
overall to the problems and applications that Cats et al already address?

** Functor and Monad
*** Functors
In my original post I introduce Functor and Monad as the gateway to Applicative.
Functor is a simple and beautiful thing, in that it allows us to combine pure
functions with "effectful" computations, mapping an F[A] to an F[B]. In prelude
Functor and Monad do not exist as first class entities, although we can see them
defined as type aliases as follows...

#+BEGIN_SRC scala
type Functor[F[+_]] = Covariant[F]
type Monad[F[+_]] = Covariant[F] with IdentityFlatten[F]
#+END_SRC

In Cats the Functor type class is actually short for Covariant Functor. What
does that mean? First of all one of the best discussions of covariance in Scala
I know can be found here on the scala-lang.org site:

https://docs.scala-lang.org/tour/variances.html

But in essence a covariant type parameter for some type A (denoted +A), means
that you can pass the type or super types of the type as that parameter.

The Cats Functor is also covariant in that if you have a function that can map
an A to a B, you can map a higher kinded type F[A] to F[B] too using the
Covariant Functor.

In Cats a Functor is defined as a higher kinded type with a map function. In
Prelude a Functor is just something that implements the Covariant type and
follows its laws.

In other words although Functor has essentially changed names in Prelude, it is
very much the same as the Cats Functor...

#+BEGIN_SRC scala
List(1,2,3).map(a => a + 1)
// List[Int] = List(2, 3, 4)
Option(1).map(a => a + 1)
// Option[Int] = Some(2)
#+END_SRC

There is an excellent post about variance and functors on the Typelevel site:

https://typelevel.org/blog/2016/02/04/variance-and-functors.html

*** Monads
In Cats we extend Functor with Applicative and add the ~flatMap~ operation to get
Monad. Applicative brings us both ~ap~ and ~pure~. Leaving ap aside for the
moment, pure is the important ability to lift a pure value into the context of
some effect, represented as a higher kinded type.

Let's take a look at sequencing two Futures together using prelude. In
order to do that with Cats we would use the Monad flatmap operation.

#+BEGIN_SRC scala
def getUser(email: String): Future[User] = ???

def getAccountStatus(id: String): Future[AccountStatus] = ???

val accountStatus = getUser("bob@google.com")
  .flatMap(user => getAccountStatus(user.accountId))
#+END_SRC

In prelude you would do the same, since nothing overrides flatMap from ZIO or
the standard library, you can simply call flatMap, but you wouldn't be
exercising the new algebraic components that make up prelude, stay tuned.

Remember above that Monad is defined as the composition of IdentityFlatten and
Covariant. We already saw that Covariant is Functor and provides map (remember
that all Monad's are functors).

IdentityFlatten is the composition of prelude types Associative, Identity and
Flatten. Flatten is easy it just gives us the ability to flatten an effect from
an F[F[A]] to an F[A]. For example the somewhat contrived code below executes a
ZIO that is nested inside another, resulting in a ZIO[ZIO[A]]. We can use the
ZIO Flatten instance to flatten and run the effects...

#+BEGIN_SRC scala
import zio._
val runtime = Runtime.default
val effect = ZIO{putStrLn("Hello!"); ZIO.succeed(10)}
runtime.unsafeRun(effect.flatten)
// Hello!
// Int = 10
#+END_SRC

Whilst most types, including ZIO effects, Future, Option and List all have
flatMap, we ~could~ define it in terms of ~Covariant~ and ~IdentityFlatten~ as follows.


#+BEGIN_SRC scala
def flatMap[F[+_]: Covariant : IdentityFlatten, A, B](fa: F[A])(fab: A => F[B]): F[B] = {
  fa.map(a => fab(a)).flatten
}
#+END_SRC

Monad also traditionally defines ~pure~, a way to lift pure values into an effect
context. We can do that with Covariant's ~map~ and IdentityFlatten's ~any~.
~any~ summons an effect out of thin air for us, and we can then use map to sneak
our pure value into that effect. Whilst this seems a little tricky, it gives a
bit more flexibility. As Adam Fraser puts it, this "also allows you to express
constraints on the types of values that can be injected through implementing
CovariantSubset instead of Covariant". Subsets were not featured in the
talk so I look forward to hearing more about that feature.

#+BEGIN_SRC scala
def pure[F[+_] : Covariant : IdentityFlatten, A](a: A)(implicit i : IdentityFlatten[F]): F[A] = {
  i.any.map(_ => a)
}
pure[Option,Int](12)
// Option[Int] = Some(12)
pure[List,String]("Hello")
// List[String] = List(Hello)
#+END_SRC

** Applicatives in Prelude
You can skip back to <a href="/2020/04/04/whats-ap.html">What's Ap?</a> if you
need to and read about Applicative again, but lets see how life is without it.

In my original post we used the ap function to apply a function to an option
using the ap function. Whilst the purpose of this was to go to explain currying
so we can apply a function to multiple effects, as parameters, here let's just
replicated it with prelude.

In prelude the equivalent to Applicative is defined as follows.

#+BEGIN_SRC scala
type Applicative[F[+_]] = Covariant[F] with IdentityBoth[F]
#+END_SRC

Covariant should be familiar, it is Functor and gives us map. IdentityBoth is
Identity with AssociativeBoth.

Associative both is product from Cats. (product can be implemented with the ap
function from Applicative)

#+BEGIN_SRC scala
override def product[A, B](fa: F[A], fb: F[B]): F[(A, B)] =
  ap(map(fa)(a => (b: B) => (a, b)))(fb)

Applicative[Option].product(Option(10), Option(12)).map{case (a,b) => a + b}
// Option[Int] = Some(22)
#+END_SRC

In prelude product is essentialy defined directly as AssociativeBoth which
implements a binary associative operator to combine two effects into an effect
containing a tuple, in other words product.

#+BEGIN_SRC scala
AssociativeBoth[Option].both(Option(10), Option(12)).map{case (a,b) => a + b}
// Option[Int] = Some(22)
#+END_SRC

Traditional Applicative requires map, ap and pure. We have map from
Covariant, the equivalent of ap using both from AssociativeBoth and pure uses
Identity just like with our Monad example...

#+BEGIN_SRC scala
def pure[F[+_] : Covariant : IdentityBoth, A](a: A)(implicit i : IdentityBoth[F]): F[A] = {
  i.any.map(_ => a)
}
pure[Option,Int](12)
// res1: Option[Int] = Some(12)
pure[List,String]("Hello")
// res2: List[String] = List(Hello)
#+END_SRC

** Sequence and Traverse
In the seminal paper Applicative programming with Effects, the first motivating
example for applicative programming is the sequence function. You have a list of
effects, specifically Haskell IO effects, and you would like to turn them into
an IO[List[A]]. You might recognise this as having the same shape and purpose as
Future.sequence from the Scala standard library. sequence is built with its more
powerful friend traverse.

#+BEGIN_SRC scala
Future.sequence is a function IterableOnce[Future[A]] => Future[IterableOnce[A]]
Future.traverse is a function IterableOnce[A], A => Future[B] => Future[IterableOnce[B]]
#+END_SRC

In Typelevel Cats, the Traverse typeclass makes this more flexible by allows us
to traverse over any type that is a functor (you can map over it) and foldable
(you can fold it with foldLeft, foldRight and fold).

#+BEGIN_SRC scala
trait Traverse[F[_]] extends Functor[F] with Foldable[F] {
 def traverse[G[_]: Applicative, A, B](fa: F[A])(f: A => G[B]): G[F[B]]
}
#+END_SRC


What's interesting about Traverse is that it relies on a number of type classes
to build its expressive power. Ultimately our little friend ~ap~ is the king pin
of the whole thing, allowing us to combine the effects together as we fold in a
way that is "idiomatic" to the effect type. When we traverse a list of Id for
example (the identity monad) we get map, and when we traverse a list of Const,
we get fold. In other words changing the data type is all we need to make
drastically different programs.

To demonstrate this in my applicative post, I wrote an implementation of a silly
algorithm called Sleep Sort. Sleep Sort works by waiting an amount of time based
on the value of the number. Emitting the numbers in this way sorts them
(assuming your scheduler is accurate enough). Let's be clear, this is a stupid
way to sort numbers, but it does represent some real world needs we have like
being able to run effects in parallel.

#+BEGIN_SRC scala
import zio._
import zio.prelude._
import zio.console._
import zio.clock._
def delayedPrintNumber(s: Int): ZIO[Console with Clock,String,Int] = {
    putStrLn(s"Preparing to say number in $s seconds") *>
    putStrLn(s"$s").delay(s.seconds) *>
    ZIO.succeed(s)
}
val ios = List(6,5,2,1,3,8,4,7).map(delayedPrintNumber)
// ios: List[ZIO[Console with Clock,String,Int]]
#+END_SRC

Using Cats we can use Traverse.sequence to flip the List[Zio] to ZIO[List] and
then execute it.

#+BEGIN_SRC scala
import cats.__
import cats.Traverse
val runtime = Runtime.default
val program = Traverse[List].traverse(ios)
runtime.unsafeRun(program)
#+END_SRC

Sadly we find this does not work because wanted all the effects to start at once
and then complete at their alloted times, making the sort work. Instead we'll
see each executed in sequence.

#+BEGIN_SRC
Monadic version

Preparing to say number in 6 seconds
6
Preparing to say number in 5 seconds
5
// ... and so on for a while
#+END_SRC

Happily thanks to the joys of Applicative we can fix this by changing the data
type. If we rewrite using Cats Effect we wrap our IO into a different type
called Par.IO which has a different implementation of applicative that does NOT
sequence the IOs together but allows them to run in parallel, we can get the
sleep sort behaviour. We didn't change the structure of our code, just the data
type!

Now all of the effects started at the same time and ran in parallel.

#+BEGIN_SRC
Preparing to say number in 6 seconds
Preparing to say number in 2 seconds
Preparing to say number in 1 seconds
Preparing to say number in 3 seconds
Preparing to say number in 8 seconds
Preparing to say number in 4 seconds
Preparing to say number in 7 seconds
Preparing to say number in 5 seconds
1
2
3
4
5
6
7
8
#+END_SRC

** ZIO Effects and Prelude
Let's visit the same problem using our ZIO effects above. One thing I like about
prelude is how combinations of its algebras are mapped to ZIO effects. In this
table we have two ZIO effects ~fa : ZIO[R, E, A]~ and ~fb : ZIO[R, E, B]~ that
are combined in different ways just by changing the algebra.

| Algebra           | ZIO instance implementation | Description                                                  |
|-------------------+-----------------------------+--------------------------------------------------------------|
| AssociativeBoth   | fa zip fb                   | fa first then fb iff fa succeeds, returning ZIO[R,E,(A,B)]   |
| AssociativeEither | fa.orElseEither(fb)         | fa first then if it fails fb, returning ZIO[R,E,Either[A,B]] |
| CommutativeBoth   | fa zipPar fb                | fa and fb at the same time, returning ZIO[R,E,(A,B)]         |

This is really nice and similar in spirit to what we did with Cats Traverse.

ZIO's implementation of Traverse has eschewed conventional names for some
functions in favour or more common words, so for example sequence is just flip,
which describes the flipping of the F[G[A]] to a G[F[A]]. We should be able to
just flip our list of ZIOs and execute them using traverse.

However, when we come back to Traverable prelude's (version of Traverse) there
are two difficulties.

*** Problem 1. Traversable doesn't handle empty structures
Perhaps by design, you cannot just take a list of ZIO effects and Traverse them,
because the flip function requires the G parameter to have the IdentityBoth
algebra. That algebra lets us combine two effects to a tuple, and there is an
identity element. ZIO effects do not have an instance of the IdentityBoth
algebra and as such cannot be used with Traverable.

We can get around this by using the NonEmptyTraversable which implements the
Traversable type class for non empty structures. Its functions are postfixed
with a 1 to indicate they require at least one element to work with, and use
AssociativeBoth algebra which ZIO has as you can see above.

*** Problem 2. We don't have a way to change from sequenced to parallel execution
When we were dealing with Applicatives we can change the data type to select a
different applicative and get a different combining method. This is a crucial
part of Traverse IMHO. This functionality is missing because the algebra is
hardcoded. We can't used the Algebra of choice from the table above (we would
need to use CommutativeBoth to get the parallel execution the sleep sort needs).

*** Running the code
#+BEGIN_SRC scala
val runtime = Runtime.default
runtime.unsafeRun(NonEmptyTraversable[NonEmptyList].flip1(ios))
#+END_SRC

Sadly the best we can do at the moment is to use flip1 but we are limited to
sequential execution.

*** Solutions
I talked to Adam Fraser about this and the probably solution will be a
forthcoming newtype called Parallel which can wrap your effects with. This would
work but feels a bit strange because we already had algebras that change
behaviours but we can't freely use them in this context, and having additional
newtypes seems like it violates the don't repeat yourself (DRY) prinicple.

Another possible solution would be to have additional Traverse types with
different algebras. Neither solution seems as clean as the Applicative one at
this point.

** Conclusion
I've been looking forward to prelude for a couple of months since I heard of its
existent on the grapevine. Overall there are some very nice aspects to the
library; the coherent and simple newtypes, the new ZPure (a swiss army knife of
useful monads in a box?) and the idea of composing your type classes from
small do one thing well algebras.

As zio-prelude evolves I expect it will at first grow, then shed some features
into modules or libraries, before shrinking to a smaller but coherent core.

I also predict it will create further bifurcation in the Scala FP community. As
it becomes more tightly integrated with ZIO it will surely attract some ZIO
programmers to give prelude their attention. For beginners there is now another
choice for developing FP skills; learn the Haskell-motivated original type class
encoding, or start with the prelude way. There's not a lot of overlap between
the two.

** References
*** Videos
- [[https://youtu.be/OwmHgL9F_9Q][SF Scala: Reimagining Functional Type Classes]]
- [[https://youtu.be/_LDk9BU_Rmc][What's ap?]]
*** Code
- [[https://github.com/justinhj/applicatives][applicatives]] (Scala conversion from the paper and lots of Applicative stuff)
- [[https://github.com/zio/zio-prelude][zio-prelude]] (A full on system for Monadic and Applicative programming)

\copy 2020 Justin Heyes-Jones. All Rights Reserved.
