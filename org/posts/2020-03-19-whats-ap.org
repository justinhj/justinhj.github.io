#+TITLE: What's Ap?
#+AUTHOR: Justin Heyes-Jones
#+DATE: 2020
#+STARTUP: showall
#+OPTIONS: toc:nil
#+HTML_HTML5_FANCY:
#+CREATOR: <a href="https://www.gnu.org/software/emacs/">Emacs</a> 26.3 (<a href="http://orgmode.org">Org</a> mode 9.4)
#+BEGIN_EXPORT html
---
layout: post
title: What's Ap?
date: '2020-03-19T00:00:00.000-08:00'
tags: [pure-functional-programming, cats, scala, applicative]
---
#+END_EXPORT
** Applicative Functors
This post is aimed at the Scala programmer who is familiar with the basics of
the language and ideally becoming interested, or already deeply entrenched, in
pure functional programming and curious about ~Applicative Functors~. We'll
delve into the original paper in which they were introduced, converting the
Haskell code to modern Scala, and then look at an efficient implementation of
blending two images using Applicative progamming.
** Functor and Monad
As a Scala programmer you will be no doubt be familar with the ~map~ and
~flatMap~ functions, which you will find in some of the collections and other
data types in the standard Scala library. If you're interested in pure
functional programming, and have used the Cats or Scalaz libraries, you may know
that these two functions are part of the ~Functor~ and ~Monad~ type classes
respectively.

Before looking at ~Apply~ and ~Applicative~ let's review what you can do
Functors and Monads.

Remember, the goal of functional programming is to do most of our work using
pure functions. We use structures like Functors and Monads to manage effects
that are not pure; letting us use pure functions in an effectful world. The
Functor type class gives us the power to take a pure function like ~a => a + 1~
and apply it to the value inside an effect. Here's an example using instances of
the Functor monad for List and Option...

#+BEGIN_SRC scala
List(1,2,3).map(a => a + 1)
// res: List[Int] = List(2, 3, 4)

Option(1).map(a => a + 1)
// res: Option[Int] = Some(2)
#+END_SRC

Whilst Functor gives you the ability to reach inside an effect, apply a pure
function to the value inside there, and wrap it up inside an effect of the same
type. The type signature of map is ~map[A,B](fa: F[A], f: A => B): F[B]~.

Monad instances have two functions. The first, ~pure~ or ~unit~, gives us a way
to lift pure values into an effectful context. ~pure[A](a: A) F[A]~ and you can
think of it as being a type constructor...

#+BEGIN_SRC scala
import cats._
import cats.implicits._

1.pure[List]
// res: List[Int] = List(1)

1.pure[Option]
// res: Option[Int] = Some(1)
#+END_SRC

Pure isn't really giving us something we didn't already have; we could make a
list and an option before. But the pure function is useful as a building block
when building code that uses Monad instances. We'll see it in use later.

Finally, Monad has the ~flatMap~ function. The signature is ~flatMap[A,B](fa:
F[A], f: A => [B]): F[B]~. flatMap comes in handy when we compose two effects
together. It let's you get the result from the first and pass it as a (pure) parameter
to the next. For example, imagine we have two calls that go out over the network
to a database or external service and we use map to chain them together...

#+BEGIN_SRC scala
def getUser(email: String): Future[User] = ???

def getAccountStatus(id: String): Future[AccountStatus] = ???

val accountStatus = getUser("bob@google.com")
  .map(user => getAccountStatus(user.accountId))
// accountStatus has type Future[Future[AccountStatus]]
#+END_SRC

Dealing with nested effects like ~Future[Future[_]]~ creates a burden on us to
reach inside the layers one at a time. If we used flatMap instead it would take
care of flattening the result for us...

#+BEGIN_SRC scala
val accountStatus = getUser("bob@google.com")
  .flatMap(user => getAccountStatus(user.accountId))
// accountStatus has type [Future[AccountStatus]
#+END_SRC

That is the essence of Monad's; being able to compose effects together. Note
that the second call is dependent on the first. It would make no sense to call
~getAccountStatus~ before we called ~getUser~ because we need the user's account
ID. In fact, even if these two effects were completely independent, we would
still have to wait for the first one before calling the second. That's not an
ideal situation because these calls may take tens or even a few hundred
milliseconds. If we want the service to be low latency, we would like to run
these calls concurrently instead of in sequence.
** What's Ap?
Now we're caught up Functors and Monads, let's look at the ~Applicative~
typeclass. It is defined as follows in Cats, with some details removed...

#+BEGIN_SRC scala
trait Applicative[F[_]] extends Apply[F] {
  def pure[A](x: A): F[A]
}
#+END_SRC

If you make an instance of Applicative then you need to supply an implementation
of ~pure~ which is exactly the same as pure found in Monads. You also need to
implement ~Apply~ which looks like this...

#+BEGIN_SRC scala
trait Apply[F[_]] extends Functor[F] {
  def ap[A, B](ff: F[A => B])(fa: F[A]): F[B]
}
#+END_SRC

You can see that ~Apply~ extends Functor which means it has map. Also it has the
function ~ap~ which is, of course, the main subject of this post. What a curious
type signature! Just like with ~map~ we are dealing with an effect type ~F~, and
a parameter ~F[A]~. The difference is the function we want to /apply/ (~ff: F[A
=> B]=~) is also /inside the effect/.

Before talking about what this is useful for, let's look at what it actually
does for various implementations.

*** Applicative instance for Option

#+BEGIN_SRC scala
Option((a:Int) => a + 10).ap(Option(20))
// res: Option[Int] = Some(30)

Option((a:Int) => a + 10).ap(None)
// res: Option[Int] = None

Option.empty[Int => Int].ap(Option(20))
// res: Option[Int] = None

Option.empty[Int => Int].ap(Option.empty[Int])
// res: Option[Int] = None
#+END_SRC

The ap function for Option, then, behaves probably as you'd expect. When you
/apply/ the function, if the ~ff~ argument is ~None~ then there's nothing to
apply and we get the result ~None~. If there is a function in there, we extract
it so that we have a /pure function/ that we can /apply/ to the effectful
argument ~F[A]~. Again, if that is empty we get ~None~, otherwise we get the
value ~f(a)~ which will be wrapped back up in the effect giving ~Some(30)~.

*** Applicative instance for List

#+BEGIN_SRC scala
List((a:Int) => a + 1,
     (a:Int) => a - 10,
     (a:Int) => a + 22).ap(List(1,2,3))
// res: List[Int] = List(2, 3, 4, -9, -8, -7, 23, 24, 25)
#+END_SRC

For ~List~ the input value for ~ff~ has the signature ~List[A => B]~, and each
function in the list is applied to each argument in the input list.

*** Idomaticly apply all the things
All data types that have instances of Applicative have a way to apply a
function wrapped in an effect of that type, and the way that it is applied is
/idomatic/ to that effect. In fact, before the name ~Applicative Functor~ stuck,
they were called ~Idioms~.

You may be scratching your head at this point, for it's not often in programming
that you want to apply a list of functions to a list (although I'm sure you can
probably come up with some ways to use it), and how often do you have functions
in Options? It gets weirder in the case of other data types. With ~Future~, or
~IO~, for example, do you ever remember writing a function that returns a
function from a Future? It's certainly rare. Still more strange would be a
function inside a ~State~ monad, but that is perfectly valid too...

#+BEGIN_SRC scala
import cats.data.State

// Create a function in a State
val fs = State[Int, (Int => Int)]
  (s => (s, (a: Int) => a + s))

// Now to apply it to an appropriate State
val applied = fs.ap(State[Int, Int](s => (s,10)))

// Finally run the Applicative State and grab the value
applied.run(10).value
//res: (Int, Int) = (10, 20)
#+END_SRC

So, everything that has an Applicative can handle pure functions that have been
lifted into effects. In some cases that seems marginally useful and in other
cases seems rather weird. Why is that? I'm going to bury the lede and in the
next section we'll back up a bit and look at the original paper that motivated
Applicative Functors back in 2008.

** Applicative Programming with Effects

In this section we'll walk through some sections of the 2008 paper by McBride
and Patterson, Applicative Programming with Effects, converting the original
Haskell into working Scala code.

[[https://www.staff.city.ac.uk/~ross/papers/Applicative.pdf]]

#+BEGIN_QUOTE
This is the story of a pattern that popped up time and again in our daily work,
programming in Haskell (Peyton Jones, 2003), until the temptation to abstract it
became irresistable. Let us illustrate with some examples.
#+END_QUOTE

We'll walk through each of the three examples...

*** Sequencing Commands
#+BEGIN_QUOTE
One often wants to execute a sequence of commands and
collect the sequence of their responses, and indeed there is such a function in the
Haskell Prelude (here specialised to IO)
#+END_QUOTE
#+BEGIN_SRC haskell
sequence :: [IO a ] → IO [a ]
sequence [ ] = return [ ]
sequence (c : cs) = do
  x ← c
  xs ← sequence cs
#+END_SRC

Before we get started, if you're following along in your Scala IDE or REPL you
will need some imports listed below. You can also clone the Github repository.

#+BEGIN_SRC scala
import zio._
import zio.console._
import zio.clock._
import zio.duration._
import cats.Applicative
import cats.implicits._
#+END_SRC

... and the following libraries ...

#+BEGIN_SRC scala
libraryDependencies ++= Seq(
 "org.typelevel" %% "cats-core" % "2.1.1",
 "dev.zio" %% "zio" % "1.0.0-RC18")
#+END_SRC

I am using ZIO in place of Haskell's IO Monad, and bringing in Cats to use its
Applicative.

Converting the sequence function from Haskell to Scala...

#+BEGIN_SRC scala
  def monadicSequence[Z,E,A](ios: List[ZIO[Z, E, A]]): ZIO[Z, E, List[A]] = {
    ios match {
      case Nil =>
        zioApplicative.pure(List.empty[A])
      case c :: cs =>
        for (
          x <- c;
          xs <- monadicSequence(cs)
        ) yield (x +: xs)
    }
  }
#+END_SRC

If you're not familiar with ~ZIO~ you can think of it as a replacement for the standard library
Scala ~Future~, but it has better performance and a lot more features. It is
also not eagerly evaluated like Future. To explain, when you create a future it runs
immediately and you cannot run it again. You can create a ZIO and run it when
you decide to and as many times as you want.

To demonstrate this sequence running let's write an implementation of a silly
algorithm called Sleep Sort. Sleep Sort works by waiting an amount of time based
on the value of the number. Emitting the numbers in this way sorts them
(assuming your scheduler is accurate enough). Let's be clear, this is a stupid
way to sort numbers, but it's handy as a way to illustrate our ~monadicSequence~
function.

#+BEGIN_SRC scala
def delayedPrintNumber(s: Int): ZIO[Console with Clock,String,Int] = {
    putStrLn(s"Preparing to say number in $s seconds") *>
    putStrLn(s"$s").delay(s.seconds) *>
    ZIO.succeed(s)
}
val ios1 = List(6,5,2,1,3,8,4,7).map(delayedPrintNumber)
// ios1: List[ZIO[Console with Clock,String,Int]]
#+END_SRC

The function creates an IO effect, which when run will immediately print a
message and then wait ~s~ seconds before printing the number. We map the
function across a list of numbers to generate a list of IO effects, which we can
then run.

You may be surprised that this does not work. Instead of running all the effects
at once and printing them out in order it just executes the first IO (wait 6
seconds), then the second (wait 5 seconds).

#+BEGIN_SRC
Monadic version

Preparing to say number in 6 seconds
6
Preparing to say number in 5 seconds
5
// ... and so on for a while
#+END_SRC

If you were not surprised maybe you're ahead of me, and know that our
~monadicSequence~ function cannot possibly run all the effects at once by virtue
of it being monadic in the first place.

That ~for~ comprehension is really hiding that we are calling flatMap on each
successive IO, and flatMap sequences things together. You must wait for the
result of the first effect before you can evaluate the second. So whilst the
first implementation of ~sequence~ in the paper will absolutely work, it will
not let us implement our sleep sort, nor let us parallelize the IO's in general.

Anyway let's get back to the paper, at this point the authors observe...

#+BEGIN_QUOTE
In the (c : cs) case, we collect the values of some effectful computations, which we
then use as the arguments to a pure function (:). We could avoid the need for names
to wire these values through to their point of usage if we had a kind of ‘effectful
application’.
#+END_QUOTE

By effectful application they are talking about the ~ap~ function, and they go
on to say that it lives in the Haskell Monad library. Given that function they
rewrite the ~sequence~ function as follows...

#+BEGIN_SRC haskell
sequence :: [IO a ] → IO [a ]
sequence [ ] = return [ ]
sequence (c : cs) = return (:) ‘ap‘ c ‘ap‘ sequence cs
#+END_SRC

#+BEGIN_QUOTE
Except for the noise of the returns and aps, this definition is in a fairly standard
applicative style, even though effects are present.
#+END_QUOTE

Note that the ~ap~ they are using here is in the Monad library, and implemented
using flatMap, so it will not yet allow our sleep sort to work. However, I've
implemented an Applicative instance for ZIO which does not have that
limitation...

#+BEGIN_SRC scala
implicit def zioApplicative[Z,E] = new Applicative[ZIO[Z,E,?]] {
    def pure[A](x: A) = ZIO.succeed(x)
    def ap[A, B](ff: ZIO[Z,E,A => B])(fa: ZIO[Z,E,A]) = {
      map2(ff, fa){
        (f,a) =>
          f(a)
      }
    }
    override def map2[A, B, C](fa: ZIO[Z,E,A], fb: ZIO[Z,E,B])(f: (A, B) => C) :
      ZIO[Z,E,C] = {
        fa.zipPar(fb).map{case (a,b) => f(a,b)}
    }
  }
#+END_SRC

It's not important to understand all the details here, all you need understand
is we now have an ~ap~ that we can apply to ZIO effects that is truly parallel,
so if you're not interested then skip to the next paragraph.

#+BEGIN_aside
The ~pure~ function is straightforward, it just wraps a pure value in a
succeeded ZIO. The ~ap~ function is more interesting. Whilst it's not obvious
how you would implemented ap in for ZIO, it is really easy to implement ~map2~.
~map2~ comes in handy because it lets you take the results of two effects and
pass them to a pure function. The function has the signature ~f: (A, B) => C~.
We use the ZIO function ~zipPar~ to execute the two effects _in parallel_, and
if both ~fa~ and ~fb~ yield values then they are mapped with the pure function
giving us a ZIO with the final result inside. Happily, you can implement ap in
terms of map2, so that solves our problem.
#+END_aside

Here's the conversion of the applicative version of ~sequence~ to Scala...

#+BEGIN_SRC scala
def applicativeSequence[Z,E,A](ios: List[ZIO[Z, E, A]]): ZIO[Z, E, List[A]] = {
    ios match {
      case Nil =>
        ZIO.succeed(List.empty[A])
      case c :: cs =>
        val ff: ZIO[Z,E, A => (List[A] => List[A])] =
          zioApplicative.pure(((a: A) => (listA: List[A]) => a +: listA))
        val p1 = ff.ap(c)
        p1.ap(applicativeSequence(cs))
    }
  }
#+END_SRC

It's a little bit noisier than the Haskell code, but most of that is having to
be more verbose about the types to keep the type checker happy. In fact the
parts of each implementation match up together.

Now we can run that and you will see that the effects are now parellelised and
our sleep sort works!

#+BEGIN_SRC
Applicative version

Preparing to say number in 6 seconds
Preparing to say number in 2 seconds
Preparing to say number in 1 seconds
Preparing to say number in 3 seconds
Preparing to say number in 8 seconds
Preparing to say number in 4 seconds
Preparing to say number in 7 seconds
Preparing to say number in 5 seconds
1
2
3
4
5
6
7
8
#+END_SRC

Note that the point the authors were making here was just to show that the
~sequence~ function is a pattern that came up often, that could be more
succinctly expressed with ~ap~.
