---
layout: post
title: What's Ap?
date: '2020-03-19T00:00:00.000-08:00'
tags: [pure-functional-programming, cats, scala, applicative]
---
<div id="outline-container-org26ff951" class="outline-2">
<h2 id="org26ff951">Applicative Functors</h2>
<div class="outline-text-2" id="text-org26ff951">
<p>
This post is aimed at the Scala programmer who is familiar with the basics of
the language and ideally becoming interested, or already deeply entrenched, in
pure functional programming and curious about <code>Applicative Functors</code>. We&rsquo;ll
delve into the original paper in which they were introduced, converting the
Haskell code to modern Scala, and then look at an efficient implementation of
blending two images using Applicative progamming.
</p>
</div>
</div>
<div id="outline-container-org38ebe47" class="outline-2">
<h2 id="org38ebe47">Functor and Monad</h2>
<div class="outline-text-2" id="text-org38ebe47">
<p>
As a Scala programmer you will be no doubt be familar with the <code>map</code> and
<code>flatMap</code> functions, which you will find in some of the collections and other
data types in the standard Scala library. If you&rsquo;re interested in pure
functional programming, and have used the Cats or Scalaz libraries, you may know
that these two functions are part of the <code>Functor</code> and <code>Monad</code> type classes
respectively.
</p>

<p>
Before looking at <code>Apply</code> and <code>Applicative</code> let&rsquo;s review what you can do
Functors and Monads.
</p>

<p>
Remember, the goal of functional programming is to do most of our work using
pure functions. We use structures like Functors and Monads to manage effects
that are not pure; letting us use pure functions in an effectful world. The
Functor type class gives us the power to take a pure function like <code>a =&gt; a + 1</code>
and apply it to the value inside an effect. Here&rsquo;s an example using instances of
the Functor monad for List and Option&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a9a1e1;">List</span>(<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #da8548; font-weight: bold;">3</span>).map(a <span style="color: #51afef;">=&gt;</span> a + <span style="color: #da8548; font-weight: bold;">1</span>)
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">res: List[Int] = List(2, 3, 4)</span>

<span style="color: #a9a1e1;">Option</span>(<span style="color: #da8548; font-weight: bold;">1</span>).map(a <span style="color: #51afef;">=&gt;</span> a + <span style="color: #da8548; font-weight: bold;">1</span>)
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">res: Option[Int] = Some(2)</span>
</pre>
</div>

<p>
Whilst Functor gives you the ability to reach inside an effect, apply a pure
function to the value inside there, and wrap it up inside an effect of the same
type. The type signature of map is <code>map[A,B](fa: F[A], f: A =&gt; B): F[B]</code>.
</p>

<p>
Monad instances have two functions. The first, <code>pure</code> or <code>unit</code>, gives us a way
to lift pure values into an effectful context. <code>pure[A](a: A) F[A]</code> and you can
think of it as being a type constructor&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">import</span> cats.<span style="color: #51afef;">_</span>
<span style="color: #51afef;">import</span> cats.implicits.<span style="color: #51afef;">_</span>

<span style="color: #da8548; font-weight: bold;">1</span>.pure[<span style="color: #a9a1e1;">List</span>]
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">res: List[Int] = List(1)</span>

<span style="color: #da8548; font-weight: bold;">1</span>.pure[<span style="color: #a9a1e1;">Option</span>]
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">res: Option[Int] = Some(1)</span>
</pre>
</div>

<p>
Pure isn&rsquo;t really giving us something we didn&rsquo;t already have; we could make a
list and an option before. But the pure function is useful as a building block
when building code that uses Monad instances. We&rsquo;ll see it in use later.
</p>

<p>
Finally, Monad has the <code>flatMap</code> function. The signature is <code>flatMap[A,B](fa:
F[A], f: A =&gt; [B]): F[B]</code>. flatMap comes in handy when we compose two effects
together. It let&rsquo;s you get the result from the first and pass it as a (pure) parameter
to the next. For example, imagine we have two calls that go out over the network
to a database or external service and we use map to chain them together&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">getUser</span>(email<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">String</span>)<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Future</span>[<span style="color: #a9a1e1;">User</span>] <span style="color: #51afef;">=</span> ???

<span style="color: #51afef;">def</span> <span style="color: #c678dd;">getAccountStatus</span>(id<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">String</span>)<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Future</span>[<span style="color: #a9a1e1;">AccountStatus</span>] <span style="color: #51afef;">=</span> ???

<span style="color: #51afef;">val</span> <span style="color: #dcaeea;">accountStatus</span> <span style="color: #51afef;">=</span> getUser(<span style="color: #98be65;">"bob@google.com"</span>)
  .map(user <span style="color: #51afef;">=&gt;</span> getAccountStatus(user.accountId))
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">accountStatus has type Future[Future[AccountStatus]]</span>
</pre>
</div>

<p>
Dealing with nested effects like <code>Future[Future[_]]</code> creates a burden on us to
reach inside the layers one at a time. If we used flatMap instead it would take
care of flattening the result for us&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">val</span> <span style="color: #dcaeea;">accountStatus</span> <span style="color: #51afef;">=</span> getUser(<span style="color: #98be65;">"bob@google.com"</span>)
  .flatMap(user <span style="color: #51afef;">=&gt;</span> getAccountStatus(user.accountId))
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">accountStatus has type [Future[AccountStatus]</span>
</pre>
</div>

<p>
That is the essence of Monad&rsquo;s; being able to compose effects together. Note
that the second call is dependent on the first. It would make no sense to call
<code>getAccountStatus</code> before we called <code>getUser</code> because we need the user&rsquo;s account
ID. In fact, even if these two effects were completely independent, we would
still have to wait for the first one before calling the second. That&rsquo;s not an
ideal situation because these calls may take tens or even a few hundred
milliseconds. If we want the service to be low latency, we would like to run
these calls concurrently instead of in sequence.
</p>
</div>
</div>
<div id="outline-container-orgffa620d" class="outline-2">
<h2 id="orgffa620d">What&rsquo;s Ap?</h2>
<div class="outline-text-2" id="text-orgffa620d">
<p>
Now we&rsquo;re caught up Functors and Monads, let&rsquo;s look at the <code>Applicative</code>
typeclass. It is defined as follows in Cats, with some details removed&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">trait</span> <span style="color: #ECBE7B;">Applicative</span>[<span style="color: #a9a1e1;">F</span>[<span style="color: #51afef;">_</span>]] <span style="color: #51afef;">extends</span> <span style="color: #ECBE7B;">Apply</span>[<span style="color: #a9a1e1;">F</span>] {
  <span style="color: #51afef;">def</span> <span style="color: #c678dd;">pure</span>[<span style="color: #a9a1e1;">A</span>](x<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">A</span>)<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">F</span>[<span style="color: #a9a1e1;">A</span>]
}
</pre>
</div>

<p>
If you make an instance of Applicative then you need to supply an implementation
of <code>pure</code> which is exactly the same as pure found in Monads. You also need to
implement <code>Apply</code> which looks like this&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">trait</span> <span style="color: #ECBE7B;">Apply</span>[<span style="color: #a9a1e1;">F</span>[<span style="color: #51afef;">_</span>]] <span style="color: #51afef;">extends</span> <span style="color: #ECBE7B;">Functor</span>[<span style="color: #a9a1e1;">F</span>] {
  <span style="color: #51afef;">def</span> <span style="color: #c678dd;">ap</span>[<span style="color: #a9a1e1;">A</span>, <span style="color: #a9a1e1;">B</span>](ff<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">F</span>[<span style="color: #a9a1e1;">A</span> <span style="color: #51afef;">=&gt;</span> <span style="color: #a9a1e1;">B</span>])(fa<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">F</span>[<span style="color: #a9a1e1;">A</span>])<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">F</span>[<span style="color: #a9a1e1;">B</span>]
}
</pre>
</div>

<p>
You can see that <code>Apply</code> extends Functor which means it has map. Also it has the
function <code>ap</code> which is, of course, the main subject of this post. What a curious
type signature! Just like with <code>map</code> we are dealing with an effect type <code>F</code>, and
a parameter <code>F[A]</code>. The difference is the function we want to <i>apply</i> (<code>ff: F[A
=&gt; B]=</code>) is also <i>inside the effect</i>.
</p>

<p>
Before talking about what this is useful for, let&rsquo;s look at what it actually
does for various implementations.
</p>
</div>

<div id="outline-container-orgc54ea37" class="outline-3">
<h3 id="orgc54ea37">Applicative instance for Option</h3>
<div class="outline-text-3" id="text-orgc54ea37">
<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a9a1e1;">Option</span>((a<span style="color: #51afef;">:</span><span style="color: #ECBE7B;">Int</span>) <span style="color: #51afef;">=&gt;</span> a + <span style="color: #da8548; font-weight: bold;">10</span>).ap(<span style="color: #a9a1e1;">Option</span>(<span style="color: #da8548; font-weight: bold;">20</span>))
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">res: Option[Int] = Some(30)</span>

<span style="color: #a9a1e1;">Option</span>((a<span style="color: #51afef;">:</span><span style="color: #ECBE7B;">Int</span>) <span style="color: #51afef;">=&gt;</span> a + <span style="color: #da8548; font-weight: bold;">10</span>).ap(<span style="color: #a9a1e1;">None</span>)
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">res: Option[Int] = None</span>

<span style="color: #a9a1e1;">Option</span>.empty[<span style="color: #a9a1e1;">Int</span> <span style="color: #51afef;">=&gt;</span> <span style="color: #a9a1e1;">Int</span>].ap(<span style="color: #a9a1e1;">Option</span>(<span style="color: #da8548; font-weight: bold;">20</span>))
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">res: Option[Int] = None</span>

<span style="color: #a9a1e1;">Option</span>.empty[<span style="color: #a9a1e1;">Int</span> <span style="color: #51afef;">=&gt;</span> <span style="color: #a9a1e1;">Int</span>].ap(<span style="color: #a9a1e1;">Option</span>.empty[<span style="color: #a9a1e1;">Int</span>])
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">res: Option[Int] = None</span>
</pre>
</div>

<p>
The ap function for Option, then, behaves probably as you&rsquo;d expect. When you
<i>apply</i> the function, if the <code>ff</code> argument is <code>None</code> then there&rsquo;s nothing to
apply and we get the result <code>None</code>. If there is a function in there, we extract
it so that we have a <i>pure function</i> that we can <i>apply</i> to the effectful
argument <code>F[A]</code>. Again, if that is empty we get <code>None</code>, otherwise we get the
value <code>f(a)</code> which will be wrapped back up in the effect giving <code>Some(30)</code>.
</p>
</div>
</div>

<div id="outline-container-org78882d1" class="outline-3">
<h3 id="org78882d1">Applicative instance for List</h3>
<div class="outline-text-3" id="text-org78882d1">
<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a9a1e1;">List</span>((a<span style="color: #51afef;">:</span><span style="color: #ECBE7B;">Int</span>) <span style="color: #51afef;">=&gt;</span> a + <span style="color: #da8548; font-weight: bold;">1</span>,
     (a<span style="color: #51afef;">:</span><span style="color: #ECBE7B;">Int</span>) <span style="color: #51afef;">=&gt;</span> a - <span style="color: #da8548; font-weight: bold;">10</span>,
     (a<span style="color: #51afef;">:</span><span style="color: #ECBE7B;">Int</span>) <span style="color: #51afef;">=&gt;</span> a + <span style="color: #da8548; font-weight: bold;">22</span>).ap(<span style="color: #a9a1e1;">List</span>(<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #da8548; font-weight: bold;">3</span>))
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">res: List[Int] = List(2, 3, 4, -9, -8, -7, 23, 24, 25)</span>
</pre>
</div>

<p>
For <code>List</code> the input value for <code>ff</code> has the signature <code>List[A =&gt; B]</code>, and each
function in the list is applied to each argument in the input list.
</p>
</div>
</div>

<div id="outline-container-org422c4d1" class="outline-3">
<h3 id="org422c4d1">Idomaticly apply all the things</h3>
<div class="outline-text-3" id="text-org422c4d1">
<p>
All data types that have instances of Applicative have a way to apply a
function wrapped in an effect of that type, and the way that it is applied is
<i>idomatic</i> to that effect. In fact, before the name <code>Applicative Functor</code> stuck,
they were called <code>Idioms</code>.
</p>

<p>
You may be scratching your head at this point, for it&rsquo;s not often in programming
that you want to apply a list of functions to a list (although I&rsquo;m sure you can
probably come up with some ways to use it), and how often do you have functions
in Options? It gets weirder in the case of other data types. With <code>Future</code>, or
<code>IO</code>, for example, do you ever remember writing a function that returns a
function from a Future? It&rsquo;s certainly rare. Still more strange would be a
function inside a <code>State</code> monad, but that is perfectly valid too&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">import</span> cats.data.<span style="color: #a9a1e1;">State</span>

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Create a function in a State</span>
<span style="color: #51afef;">val</span> <span style="color: #dcaeea;">fs</span> <span style="color: #51afef;">=</span> <span style="color: #a9a1e1;">State</span>[<span style="color: #a9a1e1;">Int</span>, (<span style="color: #a9a1e1;">Int</span> <span style="color: #51afef;">=&gt;</span> <span style="color: #a9a1e1;">Int</span>)]
  (s <span style="color: #51afef;">=&gt;</span> (s, (a<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Int</span>) <span style="color: #51afef;">=&gt;</span> a + s))

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Now to apply it to an appropriate State</span>
<span style="color: #51afef;">val</span> <span style="color: #dcaeea;">applied</span> <span style="color: #51afef;">=</span> fs.ap(<span style="color: #a9a1e1;">State</span>[<span style="color: #a9a1e1;">Int</span>, <span style="color: #a9a1e1;">Int</span>](s <span style="color: #51afef;">=&gt;</span> (s,<span style="color: #da8548; font-weight: bold;">10</span>)))

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Finally run the Applicative State and grab the value</span>
applied.run(<span style="color: #da8548; font-weight: bold;">10</span>).value
<span style="color: #5B6268;">//</span><span style="color: #5B6268;">res: (Int, Int) = (10, 20)</span>
</pre>
</div>

<p>
So, everything that has an Applicative can handle pure functions that have been
lifted into effects. In some cases that seems marginally useful and in other
cases seems rather weird. Why is that? I&rsquo;m going to bury the lede and in the
next section we&rsquo;ll look back to 2008 when Applicative Functors first show up in
academic literature&#x2026;
</p>
</div>
</div>
</div>

<div id="outline-container-orga1a6532" class="outline-2">
<h2 id="orga1a6532">Applicative Programming with Effects</h2>
<div class="outline-text-2" id="text-orga1a6532">
</div>
<div id="outline-container-org4887ecc" class="outline-3">
<h3 id="org4887ecc">Let&rsquo;s Apply ourselves</h3>
<div class="outline-text-3" id="text-org4887ecc">
<p>
Applicative Functors first saw light of day in the 2008 paper by McBride and
Patterson, &ldquo;Applicative Programming with Effects&rdquo; which you can find here&#x2026;
</p>

<p>
<a href="https://www.staff.city.ac.uk/~ross/papers/Applicative.pdf">https://www.staff.city.ac.uk/~ross/papers/Applicative.pdf</a>
</p>

<p>
The paper begins with three motivating examples for the use of Applicative style&#x2026;
</p>

<blockquote>
<p>
This is the story of a pattern that popped up time and again in our daily work,
programming in Haskell (Peyton Jones, 2003), until the temptation to abstract it
became irresistable. Let us illustrate with some examples.
</p>
</blockquote>

<p>
We&rsquo;ll walk through each of these examples and convert them to use Scala&#x2026;
</p>
</div>

<div id="outline-container-org9719544" class="outline-4">
<h4 id="org9719544">Sequencing Commands</h4>
<div class="outline-text-4" id="text-org9719544">
<blockquote>
<p>
One often wants to execute a sequence of commands and
collect the sequence of their responses, and indeed there is such a function in the
Haskell Prelude (here specialised to IO)
</p>
</blockquote>
<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">sequence</span> <span style="color: #dcaeea;">::</span> [<span style="color: #ECBE7B;">IO</span> a ] <span style="color: #dcaeea;">&#8594;</span> <span style="color: #ECBE7B;">IO</span> [a ]
<span style="color: #c678dd;">sequence</span> [ ] <span style="color: #dcaeea;">=</span> return [ ]
<span style="color: #c678dd;">sequence</span> (c <span style="color: #ECBE7B;">:</span> cs) <span style="color: #dcaeea;">=</span> <span style="color: #51afef;">do</span>
  x <span style="color: #dcaeea;">&#8592;</span> c
  xs <span style="color: #dcaeea;">&#8592;</span> sequence cs
</pre>
</div>

<p>
Before we get started, if you&rsquo;re following along in your Scala IDE or REPL you
will need some imports listed below. You can also clone the Github repository.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">import</span> zio.<span style="color: #51afef;">_</span>
<span style="color: #51afef;">import</span> zio.console.<span style="color: #51afef;">_</span>
<span style="color: #51afef;">import</span> zio.clock.<span style="color: #51afef;">_</span>
<span style="color: #51afef;">import</span> zio.duration.<span style="color: #51afef;">_</span>
<span style="color: #51afef;">import</span> cats.<span style="color: #a9a1e1;">Applicative</span>
<span style="color: #51afef;">import</span> cats.implicits.<span style="color: #51afef;">_</span>
</pre>
</div>

<p>
&#x2026; and the following libraries &#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala">libraryDependencies ++= <span style="color: #a9a1e1;">Seq</span>(
 <span style="color: #98be65;">"org.typelevel"</span> %% <span style="color: #98be65;">"cats-core"</span> % <span style="color: #98be65;">"2.1.1"</span>,
 <span style="color: #98be65;">"dev.zio"</span> %% <span style="color: #98be65;">"zio"</span> % <span style="color: #98be65;">"1.0.0-RC18"</span>)
</pre>
</div>

<p>
I am using ZIO in place of Haskell&rsquo;s IO Monad, and bringing in Cats to use its
Applicative.
</p>

<p>
Converting the sequence function from Haskell to Scala&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala">  <span style="color: #51afef;">def</span> <span style="color: #c678dd;">monadicSequence</span>[<span style="color: #a9a1e1;">Z</span>,<span style="color: #a9a1e1;">E</span>,<span style="color: #a9a1e1;">A</span>](ios<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">List</span>[<span style="color: #a9a1e1;">ZIO</span>[<span style="color: #a9a1e1;">Z</span>, <span style="color: #a9a1e1;">E</span>, <span style="color: #a9a1e1;">A</span>]])<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">ZIO</span>[<span style="color: #a9a1e1;">Z</span>, <span style="color: #a9a1e1;">E</span>, <span style="color: #a9a1e1;">List</span>[<span style="color: #a9a1e1;">A</span>]] <span style="color: #51afef;">=</span> {
    ios <span style="color: #51afef;">match</span> {
      <span style="color: #51afef;">case</span> <span style="color: #a9a1e1;">Nil</span> <span style="color: #51afef;">=&gt;</span>
        zioApplicative.pure(<span style="color: #a9a1e1;">List</span>.empty[<span style="color: #a9a1e1;">A</span>])
      <span style="color: #51afef;">case</span> <span style="color: #dcaeea;">c</span> <span style="color: #ECBE7B;">::</span> <span style="color: #dcaeea;">cs</span> <span style="color: #51afef;">=&gt;</span>
        <span style="color: #51afef;">for</span> (
          x <span style="color: #51afef;">&lt;-</span> c;
          xs <span style="color: #51afef;">&lt;-</span> monadicSequence(cs)
        ) <span style="color: #51afef;">yield</span> (x +: xs)
    }
  }
</pre>
</div>

<p>
If you&rsquo;re not familiar with <code>ZIO</code> you can think of it as a replacement for the standard library
Scala <code>Future</code>, but it has better performance and a lot more features. It is
also not eagerly evaluated like Future. To explain, when you create a future it runs
immediately and you cannot run it again. You can create a ZIO and run it when
you decide to and as many times as you want.
</p>

<p>
To demonstrate this sequence running let&rsquo;s write an implementation of a silly
algorithm called Sleep Sort. Sleep Sort works by waiting an amount of time based
on the value of the number. Emitting the numbers in this way sorts them
(assuming your scheduler is accurate enough). Let&rsquo;s be clear, this is a stupid
way to sort numbers, but it&rsquo;s handy as a way to illustrate our <code>monadicSequence</code>
function.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">delayedPrintNumber</span>(s<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Int</span>)<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">ZIO</span>[<span style="color: #a9a1e1;">Console</span> <span style="color: #51afef;">with</span> <span style="color: #ECBE7B;">Clock</span>,<span style="color: #a9a1e1;">String</span>,<span style="color: #a9a1e1;">Int</span>] <span style="color: #51afef;">=</span> {
    putStrLn(s<span style="color: #98be65;">"Preparing to say number in </span><span style="color: #dcaeea;">$s</span><span style="color: #98be65;"> seconds"</span>) *&gt;
    putStrLn(s<span style="color: #98be65;">"</span><span style="color: #dcaeea;">$s</span><span style="color: #98be65;">"</span>).delay(s.seconds) *&gt;
    <span style="color: #a9a1e1;">ZIO</span>.succeed(s)
}
<span style="color: #51afef;">val</span> <span style="color: #dcaeea;">ios1</span> <span style="color: #51afef;">=</span> <span style="color: #a9a1e1;">List</span>(<span style="color: #da8548; font-weight: bold;">6</span>,<span style="color: #da8548; font-weight: bold;">5</span>,<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">3</span>,<span style="color: #da8548; font-weight: bold;">8</span>,<span style="color: #da8548; font-weight: bold;">4</span>,<span style="color: #da8548; font-weight: bold;">7</span>).map(delayedPrintNumber)
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">ios1: List[ZIO[Console with Clock,String,Int]]</span>
</pre>
</div>

<p>
The function creates an IO effect, which when run will immediately print a
message and then wait <code>s</code> seconds before printing the number. We map the
function across a list of numbers to generate a list of IO effects, which we can
then run.
</p>

<p>
You may be surprised that this does not work. Instead of running all the effects
at once and printing them out in order it just executes the first IO (wait 6
seconds), then the second (wait 5 seconds).
</p>

<pre class="example">
Monadic version

Preparing to say number in 6 seconds
6
Preparing to say number in 5 seconds
5
// ... and so on for a while
</pre>

<p>
If you were not surprised maybe you&rsquo;re ahead of me, and know that our
<code>monadicSequence</code> function cannot possibly run all the effects at once by virtue
of it being monadic in the first place.
</p>

<p>
That <code>for</code> comprehension is really hiding that we are calling flatMap on each
successive IO, and flatMap sequences things together. You must wait for the
result of the first effect before you can evaluate the second. So whilst the
first implementation of <code>sequence</code> in the paper will absolutely work, it will
not let us implement our sleep sort, nor let us parallelize the IO&rsquo;s in general.
</p>

<p>
Anyway let&rsquo;s get back to the paper, at this point the authors observe&#x2026;
</p>

<blockquote>
<p>
In the (c : cs) case, we collect the values of some effectful computations, which we
then use as the arguments to a pure function (:). We could avoid the need for names
to wire these values through to their point of usage if we had a kind of ‘effectful
application’.
</p>
</blockquote>

<p>
By effectful application they are talking about the <code>ap</code> function, and they go
on to say that it lives in the Haskell Monad library. Given that function they
rewrite the <code>sequence</code> function as follows&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">sequence</span> <span style="color: #dcaeea;">::</span> [<span style="color: #ECBE7B;">IO</span> a ] <span style="color: #dcaeea;">&#8594;</span> <span style="color: #ECBE7B;">IO</span> [a ]
<span style="color: #c678dd;">sequence</span> [ ] <span style="color: #dcaeea;">=</span> return [ ]
<span style="color: #c678dd;">sequence</span> (c <span style="color: #ECBE7B;">:</span> cs) <span style="color: #dcaeea;">=</span> return (<span style="color: #ECBE7B;">:</span>) &#8216;ap&#8216; c &#8216;ap&#8216; sequence cs
</pre>
</div>

<blockquote>
<p>
Except for the noise of the returns and aps, this definition is in a fairly standard
applicative style, even though effects are present.
</p>
</blockquote>

<p>
Note that the <code>ap</code> they are using here is in the Monad library, and implemented
using flatMap, so it will not yet allow our sleep sort to work. However, I&rsquo;ve
implemented an Applicative instance for ZIO which does not have that
limitation&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #c678dd;">implicit</span> <span style="color: #51afef;">def</span> <span style="color: #c678dd;">zioApplicative</span>[<span style="color: #a9a1e1;">Z</span>,<span style="color: #a9a1e1;">E</span>] <span style="color: #51afef;">=</span> <span style="color: #51afef;">new</span> <span style="color: #ECBE7B;">Applicative</span>[<span style="color: #a9a1e1;">ZIO</span>[<span style="color: #a9a1e1;">Z</span>,<span style="color: #a9a1e1;">E</span>,?]] {
    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">pure</span>[<span style="color: #a9a1e1;">A</span>](x<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">A</span>) <span style="color: #51afef;">=</span> <span style="color: #a9a1e1;">ZIO</span>.succeed(x)
    <span style="color: #51afef;">def</span> <span style="color: #c678dd;">ap</span>[<span style="color: #a9a1e1;">A</span>, <span style="color: #a9a1e1;">B</span>](ff<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">ZIO</span>[<span style="color: #a9a1e1;">Z</span>,<span style="color: #a9a1e1;">E</span>,<span style="color: #a9a1e1;">A</span> <span style="color: #51afef;">=&gt;</span> <span style="color: #a9a1e1;">B</span>])(fa<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">ZIO</span>[<span style="color: #a9a1e1;">Z</span>,<span style="color: #a9a1e1;">E</span>,<span style="color: #a9a1e1;">A</span>]) <span style="color: #51afef;">=</span> {
      map2(ff, fa){
        (f,a) <span style="color: #51afef;">=&gt;</span>
          f(a)
      }
    }
    <span style="color: #c678dd;">override</span> <span style="color: #51afef;">def</span> <span style="color: #c678dd;">map2</span>[<span style="color: #a9a1e1;">A</span>, <span style="color: #a9a1e1;">B</span>, <span style="color: #a9a1e1;">C</span>](fa<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">ZIO</span>[<span style="color: #a9a1e1;">Z</span>,<span style="color: #a9a1e1;">E</span>,<span style="color: #a9a1e1;">A</span>], fb<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">ZIO</span>[<span style="color: #a9a1e1;">Z</span>,<span style="color: #a9a1e1;">E</span>,<span style="color: #a9a1e1;">B</span>])(f<span style="color: #51afef;">:</span> (<span style="color: #a9a1e1;">A</span>, <span style="color: #a9a1e1;">B</span>) <span style="color: #51afef;">=&gt;</span> <span style="color: #a9a1e1;">C</span>) <span style="color: #51afef;">:</span>
      <span style="color: #a9a1e1;">ZIO</span>[<span style="color: #a9a1e1;">Z</span>,<span style="color: #a9a1e1;">E</span>,<span style="color: #a9a1e1;">C</span>] <span style="color: #51afef;">=</span> {
        fa.zipPar(fb).map{<span style="color: #51afef;">case</span> (<span style="color: #dcaeea;">a</span>,<span style="color: #dcaeea;">b</span>) <span style="color: #51afef;">=&gt;</span> f(a,b)}
    }
  }
</pre>
</div>

<p>
It&rsquo;s not important to understand all the details here, all you need understand
is we now have an <code>ap</code> that we can apply to ZIO effects that is truly parallel,
so if you&rsquo;re not interested then skip to the next paragraph.
</p>

<div class="aside">
<p>
The <code>pure</code> function is straightforward, it just wraps a pure value in a
succeeded ZIO. The <code>ap</code> function is more interesting. Whilst it&rsquo;s not obvious
how you would implemented ap in for ZIO, it is really easy to implement <code>map2</code>.
<code>map2</code> comes in handy because it lets you take the results of two effects and
pass them to a pure function. The function has the signature <code>f: (A, B) =&gt; C</code>.
We use the ZIO function <code>zipPar</code> to execute the two effects <span class="underline">in parallel</span>, and
if both <code>fa</code> and <code>fb</code> yield values then they are mapped with the pure function
giving us a ZIO with the final result inside. Happily, you can implement ap in
terms of map2, so that solves our problem.
</p>

</div>

<p>
Here&rsquo;s the conversion of the applicative version of <code>sequence</code> to Scala&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">applicativeSequence</span>[<span style="color: #a9a1e1;">Z</span>,<span style="color: #a9a1e1;">E</span>,<span style="color: #a9a1e1;">A</span>](ios<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">List</span>[<span style="color: #a9a1e1;">ZIO</span>[<span style="color: #a9a1e1;">Z</span>, <span style="color: #a9a1e1;">E</span>, <span style="color: #a9a1e1;">A</span>]])<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">ZIO</span>[<span style="color: #a9a1e1;">Z</span>, <span style="color: #a9a1e1;">E</span>, <span style="color: #a9a1e1;">List</span>[<span style="color: #a9a1e1;">A</span>]] <span style="color: #51afef;">=</span> {
    ios <span style="color: #51afef;">match</span> {
      <span style="color: #51afef;">case</span> <span style="color: #a9a1e1;">Nil</span> <span style="color: #51afef;">=&gt;</span>
        <span style="color: #a9a1e1;">ZIO</span>.succeed(<span style="color: #a9a1e1;">List</span>.empty[<span style="color: #a9a1e1;">A</span>])
      <span style="color: #51afef;">case</span> <span style="color: #dcaeea;">c</span> <span style="color: #ECBE7B;">::</span> <span style="color: #dcaeea;">cs</span> <span style="color: #51afef;">=&gt;</span>
        <span style="color: #51afef;">val</span> <span style="color: #dcaeea;">ff</span><span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">ZIO</span>[<span style="color: #a9a1e1;">Z</span>,<span style="color: #a9a1e1;">E</span>, <span style="color: #a9a1e1;">A</span> <span style="color: #51afef;">=&gt;</span> (<span style="color: #a9a1e1;">List</span>[<span style="color: #a9a1e1;">A</span>] <span style="color: #51afef;">=&gt;</span> <span style="color: #a9a1e1;">List</span>[<span style="color: #a9a1e1;">A</span>])] <span style="color: #51afef;">=</span>
          zioApplicative.pure(((a<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">A</span>) <span style="color: #51afef;">=&gt;</span> (listA<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">List</span>[<span style="color: #a9a1e1;">A</span>]) <span style="color: #51afef;">=&gt;</span> a +: listA))
        <span style="color: #51afef;">val</span> <span style="color: #dcaeea;">p1</span> <span style="color: #51afef;">=</span> ff.ap(c)
        p1.ap(applicativeSequence(cs))
    }
  }
</pre>
</div>

<p>
It&rsquo;s a little bit noisier than the Haskell code, but most of that is having to
be more verbose about the types to keep the type checker happy. In fact the
parts of each implementation match up together.
</p>

<p>
Now we can run that and you will see that the effects are now parellelised and
our sleep sort works!
</p>

<pre class="example">
Applicative version

Preparing to say number in 6 seconds
Preparing to say number in 2 seconds
Preparing to say number in 1 seconds
Preparing to say number in 3 seconds
Preparing to say number in 8 seconds
Preparing to say number in 4 seconds
Preparing to say number in 7 seconds
Preparing to say number in 5 seconds
1
2
3
4
5
6
7
8
</pre>

<p>
Note that the point the authors were making here was just to show that the
<code>sequence</code> function is a pattern that came up often, that could be more
succinctly expressed with <code>ap</code>. Showing that it also enables our effects to run
in parallel, given the correct implementation, was just to show one of the
benefits of avoiding Monad when effects are not dependent on each other.
</p>
</div>
</div>

<div id="outline-container-org9f06115" class="outline-4">
<h4 id="org9f06115">Matrix Transposition</h4>
<div class="outline-text-4" id="text-org9f06115">
<p>
The second example in the paper is that of Matrix transposition, which takes a
matrix and flips it along a diagonal. For example&#x2026;
</p>

<pre class="example">
Original matrix
 1  2  3  4  5
 6  7  8  9 10
11 12 13 14 15

Transposed matrix
 1  6 11
 2  7 12
 3  8 13
 4  9 14
 5 10 15
</pre>

<p>
In Haskell, we first see this implememtation of transpose&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">transpose</span> <span style="color: #dcaeea;">::</span> [[a ]] <span style="color: #dcaeea;">&#8594;</span> [[a ]]
<span style="color: #c678dd;">transpose</span> [ ] <span style="color: #dcaeea;">=</span> repeat [ ]
<span style="color: #c678dd;">transpose</span> (xs <span style="color: #ECBE7B;">:</span> xss) <span style="color: #dcaeea;">=</span> zipWith (<span style="color: #ECBE7B;">:</span>) xs (transpose xss)

<span style="color: #c678dd;">repeat</span> <span style="color: #dcaeea;">::</span> a <span style="color: #dcaeea;">&#8594;</span> [a ]
<span style="color: #c678dd;">repeat</span> x <span style="color: #dcaeea;">=</span> x <span style="color: #ECBE7B;">:</span> repeat x
</pre>
</div>

<p>
Let&rsquo;s translate this to Scala. The algorithm works by taking each row in turn
and <i>zipping</i> it with each subsequent row.
</p>

<p>
First we need to be careful about the function <code>repeat</code> which returns an
infinite number of whatever x is. This is used in the transpose for the last row
of the matrix where we want a number of empty lists to finish our recursion but
we don&rsquo;t know how many, so we want to just keep taking them. Since Haskell is by
default lazily evaluated this will work fine. In Scala as soon as we evaluate
repeat we will run into an infinite loop. That&rsquo;s easily fixed by switching to
<code>LazyList</code> which is part of the standard library. (Before Scala 2.13 it was
called Stream).
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">repeat</span>[<span style="color: #a9a1e1;">A</span>](a<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">A</span>)<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">LazyList</span>[<span style="color: #a9a1e1;">A</span>] <span style="color: #51afef;">=</span> a #:: repeat(a)
</pre>
</div>

<p>
The function <code>zipWith</code> has the following type signature&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">zipWith</span> <span style="color: #dcaeea;">::</span> (a <span style="color: #dcaeea;">-&gt;</span> b <span style="color: #dcaeea;">-&gt;</span> c) <span style="color: #dcaeea;">-&gt;</span> [a] <span style="color: #dcaeea;">-&gt;</span> [b] <span style="color: #dcaeea;">-&gt;</span> [c]
</pre>
</div>

<p>
In other words it takes two lists and a pure function of two arguments, and
creates a new list by applying the function to each element. It will stop once
it runs out of elements in one of the lists. Here&rsquo;s the Scala version.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">zipWith</span>[<span style="color: #a9a1e1;">A</span>, <span style="color: #a9a1e1;">B</span>, <span style="color: #a9a1e1;">C</span>](as<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">LazyList</span>[<span style="color: #a9a1e1;">A</span>], bs<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">LazyList</span>[<span style="color: #a9a1e1;">B</span>])(
      f<span style="color: #51afef;">:</span> (<span style="color: #a9a1e1;">A</span>, <span style="color: #a9a1e1;">B</span>) <span style="color: #51afef;">=&gt;</span> <span style="color: #a9a1e1;">C</span>)<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">LazyList</span>[<span style="color: #a9a1e1;">C</span>] <span style="color: #51afef;">=</span> {
    as.zip(bs).map { <span style="color: #51afef;">case</span> (<span style="color: #dcaeea;">a</span>, <span style="color: #dcaeea;">b</span>) <span style="color: #51afef;">=&gt;</span> f(a, b) }
  }
</pre>
</div>

<p>
With the pieces in place I can now implement the transpose as follows&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">transpose</span>[<span style="color: #a9a1e1;">A</span>](matrix<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">LazyList</span>[<span style="color: #a9a1e1;">LazyList</span>[<span style="color: #a9a1e1;">A</span>]])<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">LazyList</span>[<span style="color: #a9a1e1;">LazyList</span>[<span style="color: #a9a1e1;">A</span>]] <span style="color: #51afef;">=</span> {
  matrix <span style="color: #51afef;">match</span> {
    <span style="color: #51afef;">case</span> <span style="color: #ECBE7B;">LazyList</span>() <span style="color: #51afef;">=&gt;</span> repeat(<span style="color: #a9a1e1;">LazyList</span>.empty)
    <span style="color: #51afef;">case</span> <span style="color: #dcaeea;">xs</span> <span style="color: #ECBE7B;">#::</span> <span style="color: #dcaeea;">xss</span> <span style="color: #51afef;">=&gt;</span>
      zipWith(xs, transpose(xss)) {
        <span style="color: #51afef;">case</span> (<span style="color: #dcaeea;">a</span>, <span style="color: #dcaeea;">as</span>) <span style="color: #51afef;">=&gt;</span>
          a +: as
      }
  }
}
</pre>
</div>

<p>
The next step in the paper is to make this look a bit more <i>applicative</i> by
using a combination of <code>repeat</code> and <code>zapp</code>&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">zapp</span> <span style="color: #dcaeea;">::</span> [a <span style="color: #dcaeea;">&#8594;</span> b ] <span style="color: #dcaeea;">&#8594;</span> [a ] <span style="color: #dcaeea;">&#8594;</span> [b ]
<span style="color: #c678dd;">zapp</span> (f <span style="color: #ECBE7B;">:</span> fs) (x <span style="color: #ECBE7B;">:</span> xs) <span style="color: #dcaeea;">=</span> f x <span style="color: #ECBE7B;">:</span> zapp fs xs
<span style="color: #c678dd;">zapp</span> <span style="color: #dcaeea;">=</span> [ ]

<span style="color: #c678dd;">transpose</span> <span style="color: #dcaeea;">::</span> [[a ]] <span style="color: #dcaeea;">&#8594;</span> [[a ]]
<span style="color: #c678dd;">transpose</span> [ ] <span style="color: #dcaeea;">=</span> repeat [ ]
<span style="color: #c678dd;">transpose</span> (xs <span style="color: #ECBE7B;">:</span> xss) <span style="color: #dcaeea;">=</span> repeat (<span style="color: #ECBE7B;">:</span>) &#8216;zapp&#8216; xs &#8216;zapp&#8216; transpose xss
</pre>
</div>

<blockquote>
<p>
Except for the noise of the repeats and zapps, this definition is in a fairly standard
applicative style, even though we are working with vectors.
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org15f9128" class="outline-4">
<h4 id="org15f9128">Evaluating Expressions</h4>
<div class="outline-text-4" id="text-org15f9128">
<p>
The third example of applicative style is an expression evaluator that can add
numbers, both literals and numbers bound to strings and stored in an environment.
</p>

<blockquote>
<p>
When implementing an evaluator for a language of expressions, it is customary to
pass around an environment, giving values to the free variables.
</p>
</blockquote>

<p>
The Haskell code looks like this&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">data</span> <span style="color: #ECBE7B;">Exp</span> v <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">Var</span> v
  <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Val</span> <span style="color: #ECBE7B;">Int</span>
  <span style="color: #dcaeea;">|</span> <span style="color: #ECBE7B;">Add</span> (<span style="color: #ECBE7B;">Exp</span> v) (<span style="color: #ECBE7B;">Exp</span> v)

<span style="color: #c678dd;">eval</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Exp</span> v <span style="color: #dcaeea;">&#8594;</span> <span style="color: #ECBE7B;">Env</span> v <span style="color: #dcaeea;">&#8594;</span> <span style="color: #ECBE7B;">Int</span>
<span style="color: #c678dd;">eval</span> (<span style="color: #ECBE7B;">Var</span> x ) &#947; <span style="color: #dcaeea;">=</span> fetch x &#947;
<span style="color: #c678dd;">eval</span> (<span style="color: #ECBE7B;">Val</span> i) &#947; <span style="color: #dcaeea;">=</span> i
<span style="color: #c678dd;">eval</span> (<span style="color: #ECBE7B;">Add</span> p q) &#947; <span style="color: #dcaeea;">=</span> eval p &#947; <span style="color: #dcaeea;">+</span> eval q &#947;
</pre>
</div>

<p>
Converting to Scala is straightforward&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #c678dd;">sealed</span> <span style="color: #51afef;">trait</span> <span style="color: #ECBE7B;">Exp</span>
<span style="color: #51afef;">case</span> <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Val</span>(value<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Int</span>) <span style="color: #51afef;">extends</span> <span style="color: #ECBE7B;">Exp</span>
<span style="color: #51afef;">case</span> <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Add</span>(left<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Exp</span>, right<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Exp</span>) <span style="color: #51afef;">extends</span> <span style="color: #ECBE7B;">Exp</span>
<span style="color: #51afef;">case</span> <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Var</span>(key<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">String</span>) <span style="color: #51afef;">extends</span> <span style="color: #ECBE7B;">Exp</span>

<span style="color: #51afef;">case</span> <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Env</span>[<span style="color: #a9a1e1;">K</span>](kv<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Map</span>[<span style="color: #a9a1e1;">K</span>,<span style="color: #a9a1e1;">Int</span>])

<span style="color: #51afef;">def</span> <span style="color: #c678dd;">fetch</span>(key<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">String</span>)(env<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Env</span>[<span style="color: #a9a1e1;">String</span>]) <span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Int</span> <span style="color: #51afef;">=</span>
  env.kv.getOrElse(key, <span style="color: #da8548; font-weight: bold;">0</span>)

<span style="color: #51afef;">def</span> <span style="color: #c678dd;">eval</span>(exp<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Exp</span>, env<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Env</span>[<span style="color: #a9a1e1;">String</span>]) <span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Int</span> <span style="color: #51afef;">=</span> {
  exp <span style="color: #51afef;">match</span> {
    <span style="color: #51afef;">case</span> <span style="color: #ECBE7B;">Val</span>(<span style="color: #dcaeea;">value</span>) <span style="color: #51afef;">=&gt;</span> value
    <span style="color: #51afef;">case</span> <span style="color: #ECBE7B;">Var</span>(<span style="color: #dcaeea;">key</span>) <span style="color: #51afef;">=&gt;</span> fetch(key)(env)
    <span style="color: #51afef;">case</span> <span style="color: #ECBE7B;">Add</span>(<span style="color: #dcaeea;">left</span>, <span style="color: #dcaeea;">right</span>) <span style="color: #51afef;">=&gt;</span>
      eval(left, env) + eval(right, env)
  }
}
</pre>
</div>

<p>
Here I&rsquo;ve made the environment a simple key value store, and, to avoid
complicating the example with error handling, if a variable is not present in
the environment I just default to returning zero.
</p>

<p>
Following the pattern of the previous two examples, the authors then pull some
magic to make the applicative pattern more noticable&#x2026;
</p>

<blockquote>
<p>
We can eliminate the clutter of the explicitly threaded environment with a little
help from some very old friends, designed for this purpose
</p>
</blockquote>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">eval</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Exp</span> v <span style="color: #dcaeea;">&#8594;</span> <span style="color: #ECBE7B;">Env</span> v <span style="color: #dcaeea;">&#8594;</span> <span style="color: #ECBE7B;">Int</span>
<span style="color: #c678dd;">eval</span> (<span style="color: #ECBE7B;">Var</span> x ) <span style="color: #dcaeea;">=</span> fetch x
<span style="color: #c678dd;">eval</span> (<span style="color: #ECBE7B;">Val</span> i) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">K</span> i
<span style="color: #c678dd;">eval</span> (<span style="color: #ECBE7B;">Add</span> p q) <span style="color: #dcaeea;">=</span> <span style="color: #ECBE7B;">K</span> (<span style="color: #dcaeea;">+</span>) &#8216;<span style="color: #ECBE7B;">S</span>&#8216; eval p &#8216;<span style="color: #ECBE7B;">S</span>&#8216; eval q

<span style="color: #51afef;">where</span>
<span style="color: #ECBE7B;">K</span> <span style="color: #dcaeea;">::</span> a <span style="color: #dcaeea;">&#8594;</span> env <span style="color: #dcaeea;">&#8594;</span> a
<span style="color: #ECBE7B;">K</span> x &#947; <span style="color: #dcaeea;">=</span> x

<span style="color: #ECBE7B;">S</span> <span style="color: #dcaeea;">::</span> (env <span style="color: #dcaeea;">&#8594;</span> a <span style="color: #dcaeea;">&#8594;</span> b) <span style="color: #dcaeea;">&#8594;</span> (env <span style="color: #dcaeea;">&#8594;</span> a) <span style="color: #dcaeea;">&#8594;</span> (env <span style="color: #dcaeea;">&#8594;</span> b)
<span style="color: #ECBE7B;">S</span> ef es &#947; <span style="color: #dcaeea;">=</span> (ef &#947;) (es &#947;)
</pre>
</div>

<p>
So this all looks a bit cryptic. Who are the old friends? Well, if you look at
the type signature of <code>K</code> it is actually the <code>pure</code> function, and <code>S</code>
is the <code>ap</code> function. This is in fact what we&rsquo;d call the <code>Reader</code> Monad in
Scala.
</p>

<p>
By old friends, the authors are referring to the <a href="https://en.wikipedia.org/wiki/SKI_combinator_calculus">SKI Combinator Calculus</a>.
</p>

<p>
Let&rsquo;s reimplement in Scala using the <code>Reader</code>.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">fetchR</span>(key<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">String</span>) <span style="color: #51afef;">=</span> <span style="color: #a9a1e1;">Reader</span>[<span style="color: #a9a1e1;">Map</span>[<span style="color: #a9a1e1;">String</span>,<span style="color: #a9a1e1;">Int</span>], <span style="color: #a9a1e1;">Int</span>](env <span style="color: #51afef;">=&gt;</span> env.getOrElse(key, <span style="color: #da8548; font-weight: bold;">0</span>))
<span style="color: #51afef;">def</span> <span style="color: #c678dd;">pureR</span>(value<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Int</span>) <span style="color: #51afef;">=</span> <span style="color: #a9a1e1;">Reader</span>[<span style="color: #a9a1e1;">Map</span>[<span style="color: #a9a1e1;">String</span>,<span style="color: #a9a1e1;">Int</span>], <span style="color: #a9a1e1;">Int</span>](env <span style="color: #51afef;">=&gt;</span> value)

<span style="color: #51afef;">def</span> <span style="color: #c678dd;">evalR</span>(exp<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Exp</span>)<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Reader</span>[<span style="color: #a9a1e1;">Map</span>[<span style="color: #a9a1e1;">String</span>,<span style="color: #a9a1e1;">Int</span>], <span style="color: #a9a1e1;">Int</span>] <span style="color: #51afef;">=</span> {
  exp <span style="color: #51afef;">match</span> {
    <span style="color: #51afef;">case</span> <span style="color: #ECBE7B;">Val</span>(<span style="color: #dcaeea;">value</span>) <span style="color: #51afef;">=&gt;</span> pureR(value)
    <span style="color: #51afef;">case</span> <span style="color: #ECBE7B;">Var</span>(<span style="color: #dcaeea;">key</span>) <span style="color: #51afef;">=&gt;</span> fetchR(key)
    <span style="color: #51afef;">case</span> <span style="color: #ECBE7B;">Add</span>(<span style="color: #dcaeea;">left</span>, <span style="color: #dcaeea;">right</span>) <span style="color: #51afef;">=&gt;</span>
      <span style="color: #51afef;">val</span> <span style="color: #dcaeea;">f</span> <span style="color: #51afef;">=</span> <span style="color: #a9a1e1;">Reader</span>((env<span style="color: #51afef;">:</span><span style="color: #ECBE7B;">Map</span>[<span style="color: #a9a1e1;">String</span>,<span style="color: #a9a1e1;">Int</span>]) <span style="color: #51afef;">=&gt;</span>
        (a<span style="color: #51afef;">:</span><span style="color: #ECBE7B;">Int</span>) <span style="color: #51afef;">=&gt;</span> (b<span style="color: #51afef;">:</span><span style="color: #ECBE7B;">Int</span>) <span style="color: #51afef;">=&gt;</span> a + b)
      <span style="color: #51afef;">val</span> <span style="color: #dcaeea;">leftEval</span> <span style="color: #51afef;">=</span> evalR(left).ap(f)
      evalR(right).ap(leftEval)
  }
}
</pre>
</div>

<p>
And take it for a test drive&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">val</span> <span style="color: #dcaeea;">env1</span> <span style="color: #51afef;">=</span> <span style="color: #a9a1e1;">Env</span>(<span style="color: #a9a1e1;">Map</span>(<span style="color: #98be65;">"x"</span> -&gt; <span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #98be65;">"y"</span> -&gt; <span style="color: #da8548; font-weight: bold;">10</span>))
<span style="color: #51afef;">val</span> <span style="color: #dcaeea;">exp1</span> <span style="color: #51afef;">=</span> <span style="color: #a9a1e1;">Add</span>(<span style="color: #a9a1e1;">Val</span>(<span style="color: #da8548; font-weight: bold;">10</span>), <span style="color: #a9a1e1;">Add</span>(<span style="color: #a9a1e1;">Var</span>(<span style="color: #98be65;">"x"</span>), <span style="color: #a9a1e1;">Var</span>(<span style="color: #98be65;">"y"</span>)))

println(s<span style="color: #98be65;">"Eval : </span><span style="color: #dcaeea;">${eval(exp1, env1)}</span><span style="color: #98be65;">"</span>)
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Eval : 23</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org01f79f5" class="outline-3">
<h3 id="org01f79f5">The Applicative Type class</h3>
<div class="outline-text-3" id="text-org01f79f5">
<p>
To summarize, we&rsquo;ve seen three different effects used in applicative style; IO
(or ZIO), List and Reader. Now you can see why it makes sense to be able to
apply a function that is wrapped in these effects. What we needed, and got with
<code>ap</code>, is a way to lift a pure function so we can apply it to a chain of effects
of the same effect type.
</p>

<p>
Next in the paper the authors describe the laws which an instance of the
Applicative type class must adhere to, which is out of scope for this post but
is put succinctly in English as follows&#x2026;
</p>

<blockquote>
<p>
The idea is that pure embeds pure computations into the pure fragment of an
effectful world—the resulting computations may thus be shunted around freely, as
long as the order of the genuinely effectful computations is preserved.
</p>
</blockquote>

<p>
Next we are show that <i>Applicatives are all Functors</i> (hence the name
Applicative Functors), because you can implement the map operation as follows&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">Declare map in terms of pure and ap</span>
<span style="color: #51afef;">def</span> <span style="color: #c678dd;">map</span>[<span style="color: #a9a1e1;">A</span>,<span style="color: #a9a1e1;">B</span>,<span style="color: #a9a1e1;">F</span>[<span style="color: #51afef;">_</span>]<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Applicative</span>](fa<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">F</span>[<span style="color: #a9a1e1;">A</span>], f<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">A</span> <span style="color: #51afef;">=&gt;</span> <span style="color: #a9a1e1;">B</span>)<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">F</span>[<span style="color: #a9a1e1;">B</span>] <span style="color: #51afef;">=</span> {
  <span style="color: #a9a1e1;">Applicative</span>[<span style="color: #a9a1e1;">F</span>].pure(f).ap(fa)
}

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Map a function over a list</span>
map(<span style="color: #a9a1e1;">List</span>(<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #da8548; font-weight: bold;">3</span>,<span style="color: #da8548; font-weight: bold;">4</span>,<span style="color: #da8548; font-weight: bold;">5</span>), (a<span style="color: #51afef;">:</span><span style="color: #ECBE7B;">Int</span>) <span style="color: #51afef;">=&gt;</span> a + <span style="color: #da8548; font-weight: bold;">1</span>)
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">res: List[Int] = List(2, 3, 4, 5, 6)</span>
</pre>
</div>

<p>
Note that you don&rsquo;t have to do this with Cats instances because all
Applicatives have their Functor instance taken care of too.
</p>

<p>
The paper then notes that all uses of Applicatives follow this pattern of
lifting a pure function and applying it to a chain of effects, and suggests a
new syntax for shifting into the <i>Idiom</i> of the applicative functor. The syntax
is a special pair of brackets&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-haskell">[[ ff f1 f2 f3 <span style="color: #dcaeea;">...</span> fn ]]
</pre>
</div>

<p>
Although this has not been widely adopted in either Haskell or Scala as far as I
can tell, you can try it yourself using this delightfully named (and
implemented) Scala library: <a href="https://github.com/sammthomson/IdiomEars">Idiom Ears</a>. This will let you closely match the
syntax from the paper; for example&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">val</span> <span style="color: #dcaeea;">f</span> <span style="color: #51afef;">=</span> (a<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Int</span>) <span style="color: #51afef;">=&gt;</span> (b<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Int</span>) <span style="color: #51afef;">=&gt;</span> a * b
&#8847;| (f) (<span style="color: #a9a1e1;">List</span>(<span style="color: #da8548; font-weight: bold;">1</span>, <span style="color: #da8548; font-weight: bold;">2</span>)) (<span style="color: #a9a1e1;">List</span>(<span style="color: #da8548; font-weight: bold;">3</span>, <span style="color: #da8548; font-weight: bold;">4</span>)) |&#8848;
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">List(3, 4, 6, 8)</span>

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Which is equivalent to</span>
<span style="color: #a9a1e1;">Applicative</span>[<span style="color: #a9a1e1;">List</span>].pure(f).ap(<span style="color: #a9a1e1;">List</span>(<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">2</span>)).ap(<span style="color: #a9a1e1;">List</span>(<span style="color: #da8548; font-weight: bold;">3</span>,<span style="color: #da8548; font-weight: bold;">4</span>))
</pre>
</div>

<p>
If you do fall in love with the idiom brackets of McBride and Patterson then
knock yourself out, but you may have to invest some time bringing the project
back to life as it has suffered some bitrot since 2016. There is a demo of
IdiomEars in the Github repository accompanying this post, but I simply copied
the code into my project rather than spend time updating it.
</p>
</div>
</div>

<div id="outline-container-org2ca2038" class="outline-3">
<h3 id="org2ca2038">Moving right along to Traverse</h3>
<div class="outline-text-3" id="text-org2ca2038">
<blockquote>
<p>
Have you noticed that sequence and transpose now look rather alike? The details
that distinguish the two programs are inferred by the compiler from their types.
Both are instances of the applicative distributor for lists.
</p>
</blockquote>

<p>
At this point in the paper we have seen the birth of the Applicative type class
which encapsulates the <code>ap</code> and <code>pure</code> functions needed to implement the
patterns above. Next the authors describe another new type class, <code>Traverse</code>,
which lets us generalize the pattern further&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">dist</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Applicative</span> f <span style="color: #dcaeea;">&#8658;</span> [f a ] <span style="color: #dcaeea;">&#8594;</span> f [a ]
<span style="color: #c678dd;">dist</span> [ ] <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">&#8847;|</span> [ ] <span style="color: #dcaeea;">|&#8848;</span>
<span style="color: #c678dd;">dist</span> (v <span style="color: #ECBE7B;">:</span> vs) <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">&#8847;|</span> (<span style="color: #ECBE7B;">:</span>) v (dist vs) <span style="color: #dcaeea;">|&#8848;</span>
</pre>
</div>

<p>
Note that I&rsquo;m using the unicode from Idiom Ears to replace the fancy brackets
from the paper which I cannot reproduce here, but you get the idea. Let&rsquo;s
rewrite in Scala&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #5B6268;">// </span><span style="color: #5B6268;">applicative distributor for lists</span>
<span style="color: #51afef;">def</span> <span style="color: #c678dd;">dist</span>[<span style="color: #a9a1e1;">A</span>, <span style="color: #a9a1e1;">F</span>[<span style="color: #51afef;">_</span>]](fs<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">List</span>[<span style="color: #a9a1e1;">F</span>[<span style="color: #a9a1e1;">A</span>]])(<span style="color: #c678dd;">implicit</span> app<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Applicative</span>[<span style="color: #a9a1e1;">F</span>])<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">F</span>[<span style="color: #a9a1e1;">List</span>[<span style="color: #a9a1e1;">A</span>]] <span style="color: #51afef;">=</span> {
  fs <span style="color: #51afef;">match</span> {
    <span style="color: #51afef;">case</span> <span style="color: #a9a1e1;">Nil</span> <span style="color: #51afef;">=&gt;</span>
      app.pure(<span style="color: #a9a1e1;">List</span>.empty[<span style="color: #a9a1e1;">A</span>])
    <span style="color: #51afef;">case</span> <span style="color: #dcaeea;">c</span> <span style="color: #ECBE7B;">::</span> <span style="color: #dcaeea;">cs</span> <span style="color: #51afef;">=&gt;</span>
      <span style="color: #51afef;">val</span> <span style="color: #dcaeea;">w1</span> <span style="color: #51afef;">=</span> app.pure((a<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">A</span>) <span style="color: #51afef;">=&gt;</span> (listA<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">List</span>[<span style="color: #a9a1e1;">A</span>]) <span style="color: #51afef;">=&gt;</span> a +: listA)
      <span style="color: #51afef;">val</span> <span style="color: #dcaeea;">w2</span> <span style="color: #51afef;">=</span> w1.ap(c)
      w2.ap(dist(cs))
  }
}

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">dist a list of options</span>
println(dist(<span style="color: #a9a1e1;">List</span>(<span style="color: #a9a1e1;">Option</span>(<span style="color: #da8548; font-weight: bold;">10</span>), <span style="color: #a9a1e1;">Option</span>(<span style="color: #da8548; font-weight: bold;">10</span>), <span style="color: #a9a1e1;">Option</span>(<span style="color: #da8548; font-weight: bold;">3</span>), <span style="color: #a9a1e1;">Option</span>(<span style="color: #da8548; font-weight: bold;">4</span>))))
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Some(List(10, 10, 3, 4))</span>

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Note that we have short circuiting</span>
println(dist(<span style="color: #a9a1e1;">List</span>(<span style="color: #a9a1e1;">None</span>, <span style="color: #a9a1e1;">Option</span>(<span style="color: #da8548; font-weight: bold;">10</span>), <span style="color: #a9a1e1;">Option</span>(<span style="color: #da8548; font-weight: bold;">3</span>), <span style="color: #a9a1e1;">Option</span>(<span style="color: #da8548; font-weight: bold;">4</span>))))
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">None</span>
</pre>
</div>

<p>
Note that this short-circuits. We fail as soon as a single <code>None</code> shows up. Why?
It&rsquo;s because although applicative allows us to avoid the enforced sequencing of
Monad&rsquo;s flatMap, many types have instances of <code>ap</code> implemented in terms of
flatMap anyway, because that matches the expectation of users for that type.
</p>

<p>
We could override the Cats instance for Option with our own. What we do instead
is create Applicative versions of type classes. For example, our monadic friend
Either (which represents an error or a success value) has an applicative
alter-ego <code>Validated</code>. Rather than short-circuit on failure, Validated allows us
to acculate errors so we can provide valuable feeback ot the caller. That is one
of the super-powers of Applicatives!
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">val</span> <span style="color: #dcaeea;">someValidateds</span><span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">List</span>[<span style="color: #a9a1e1;">Validated</span>[<span style="color: #a9a1e1;">NonEmptyList</span>[<span style="color: #a9a1e1;">String</span>],<span style="color: #a9a1e1;">Int</span>]] <span style="color: #51afef;">=</span>
  (<span style="color: #a9a1e1;">List</span>(<span style="color: #98be65;">"Had some error"</span>.invalidNel, <span style="color: #da8548; font-weight: bold;">10</span>.valid, <span style="color: #98be65;">"Another error"</span>.invalidNel, <span style="color: #da8548; font-weight: bold;">4</span>.valid))

<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Try the same with Validated that has an Applicative instance</span>
println(<span style="color: #98be65;">"Validated failure example: "</span> + dist(someValidateds))
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Validated failure example: Invalid(NonEmptyList(Had some error, Another error))</span>
</pre>
</div>

<p>
Just by changing data types we have completely changed the behaviour from
short-circuiting to being able to <i>/accumulate the errors</i>. Just imagine that these
are expensive computations or slow network calls, and you can see how avoiding
sequencing can really save us in computing costs, and thereby save us money.
Furthermore we can improve user experience. We can validate a whole form from
the user at once and send all the corrections needed rather than necessitate a
painful back and forth until the whole form is valid.
</p>

<p>
Anyway enough real world talk let&rsquo;s get back to <code>dist</code>.
</p>

<blockquote>
<p>
Distribution is often used together with ‘map’.
</p>
</blockquote>

<p>
Fair enough. The <code>dist</code> function we developed above would be enhanced in
usefullness if it could map a list of pure values into some effect type first.
Let&rsquo;s take a look at a poor way to implement that&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">flakyMap</span> <span style="color: #dcaeea;">::</span> (a <span style="color: #dcaeea;">&#8594;</span> <span style="color: #ECBE7B;">Maybe</span> b) <span style="color: #dcaeea;">&#8594;</span> [a ] <span style="color: #dcaeea;">&#8594;</span> <span style="color: #ECBE7B;">Maybe</span> [b ]
<span style="color: #c678dd;">flakyMap</span> f ss <span style="color: #dcaeea;">=</span> dist (fmap f ss)
</pre>
</div>

<p>
We can translate pretty much directly to Scala&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">flakyMap</span>[<span style="color: #a9a1e1;">A</span>,<span style="color: #a9a1e1;">B</span>](f<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">A</span> <span style="color: #51afef;">=&gt;</span> <span style="color: #a9a1e1;">Option</span>[<span style="color: #a9a1e1;">B</span>], as<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">List</span>[<span style="color: #a9a1e1;">A</span>])<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Option</span>[<span style="color: #a9a1e1;">List</span>[<span style="color: #a9a1e1;">B</span>]] <span style="color: #51afef;">=</span> {
  dist(as.map(f))
}

println(<span style="color: #98be65;">"Flakymap success: "</span> + flakyMap((n<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Int</span>) <span style="color: #51afef;">=&gt;</span> <span style="color: #a9a1e1;">Option</span>(n * <span style="color: #da8548; font-weight: bold;">2</span>), <span style="color: #a9a1e1;">List</span>(<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #da8548; font-weight: bold;">3</span>)))
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Flakymap success: Some(List(2, 4, 6))</span>
println(<span style="color: #98be65;">"Flakymap failure: "</span> + flakyMap((n<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Int</span>) <span style="color: #51afef;">=&gt;</span> <span style="color: #51afef;">if</span>(n%<span style="color: #da8548; font-weight: bold;">2</span>==<span style="color: #da8548; font-weight: bold;">1</span>) <span style="color: #a9a1e1;">Some</span>(n) <span style="color: #51afef;">else</span> <span style="color: #a9a1e1;">None</span>, <span style="color: #a9a1e1;">List</span>(<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #da8548; font-weight: bold;">3</span>)))
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Flakymap failure: None</span>
</pre>
</div>

<p>
That&rsquo;s clearly useful, and it works, but it&rsquo;s flaky because we have to process
the list twice. First we map over the list to transform it, then we do it again
with the dist function. How about we do both at once? That&rsquo;s <code>Traverse</code>&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #c678dd;">traverse</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Applicative</span> f <span style="color: #dcaeea;">&#8658;</span> (a <span style="color: #dcaeea;">&#8594;</span> f b) <span style="color: #dcaeea;">&#8594;</span> [a ] <span style="color: #dcaeea;">&#8594;</span> f [b ]
<span style="color: #c678dd;">traverse</span> f [ ] <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">&#8847;|</span> [ ] <span style="color: #dcaeea;">|&#8848;</span>
<span style="color: #c678dd;">traverse</span> f (x <span style="color: #ECBE7B;">:</span> xs) <span style="color: #dcaeea;">=</span> <span style="color: #dcaeea;">&#8847;|</span> (<span style="color: #ECBE7B;">:</span>) (f x ) (traverse f xs) <span style="color: #dcaeea;">|&#8848;</span>
</pre>
</div>

<p>
And a Scala version&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">listTraverse</span>[<span style="color: #a9a1e1;">A</span>, <span style="color: #a9a1e1;">B</span>, <span style="color: #a9a1e1;">F</span>[<span style="color: #51afef;">_</span>]](f<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">A</span> <span style="color: #51afef;">=&gt;</span> <span style="color: #a9a1e1;">F</span>[<span style="color: #a9a1e1;">B</span>], fs<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">List</span>[<span style="color: #a9a1e1;">A</span>])
     (<span style="color: #c678dd;">implicit</span> app<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Applicative</span>[<span style="color: #a9a1e1;">F</span>])<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">F</span>[<span style="color: #a9a1e1;">List</span>[<span style="color: #a9a1e1;">B</span>]] <span style="color: #51afef;">=</span> {
  fs <span style="color: #51afef;">match</span> {
    <span style="color: #51afef;">case</span> <span style="color: #a9a1e1;">Nil</span> <span style="color: #51afef;">=&gt;</span>
      app.pure(<span style="color: #a9a1e1;">List</span>.empty[<span style="color: #a9a1e1;">B</span>])
    <span style="color: #51afef;">case</span> <span style="color: #dcaeea;">c</span> <span style="color: #ECBE7B;">::</span> <span style="color: #dcaeea;">cs</span> <span style="color: #51afef;">=&gt;</span>
      <span style="color: #51afef;">val</span> <span style="color: #dcaeea;">w1</span> <span style="color: #51afef;">=</span> app.pure((b<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">B</span>) <span style="color: #51afef;">=&gt;</span> (listB<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">List</span>[<span style="color: #a9a1e1;">B</span>]) <span style="color: #51afef;">=&gt;</span> b +: listB)
      <span style="color: #51afef;">val</span> <span style="color: #dcaeea;">w2</span> <span style="color: #51afef;">=</span> w1.ap(f(c))
      w2.ap(listTraverse(f, cs))
  }
}
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Output is the same as flakyMap</span>
</pre>
</div>

<p>
By providing the identity function for <code>f</code> we get the <code>sequence</code> function back
in terms of traverse&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">sequence</span>[<span style="color: #a9a1e1;">A</span>, <span style="color: #a9a1e1;">F</span>[<span style="color: #51afef;">_</span>]](fs<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">List</span>[<span style="color: #a9a1e1;">F</span>[<span style="color: #a9a1e1;">A</span>]])
    (<span style="color: #c678dd;">implicit</span> app<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Applicative</span>[<span style="color: #a9a1e1;">F</span>])<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">F</span>[<span style="color: #a9a1e1;">List</span>[<span style="color: #a9a1e1;">A</span>]] <span style="color: #51afef;">=</span> {
  listTraverse((fa<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">F</span>[<span style="color: #a9a1e1;">A</span>]) <span style="color: #51afef;">=&gt;</span> fa, fs)
}
</pre>
</div>

<p>
Finally we get to the Traverse type class, which gives us an interface to write
traverse for two effect types rather than just List and another effect. We have
two functions, traverse and dist, which are represented in Scala today as
traverse and sequence.
</p>

<div class="org-src-container">
<pre class="src src-haskell"><span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Traversable</span> t <span style="color: #51afef;">where</span>
<span style="color: #c678dd;">traverse</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Applicative</span> f <span style="color: #dcaeea;">&#8658;</span> (a <span style="color: #dcaeea;">&#8594;</span> f b) <span style="color: #dcaeea;">&#8594;</span> t a <span style="color: #dcaeea;">&#8594;</span> f (t b)
<span style="color: #c678dd;">dist</span> <span style="color: #dcaeea;">::</span> <span style="color: #ECBE7B;">Applicative</span> f <span style="color: #dcaeea;">&#8658;</span> t (f a) <span style="color: #dcaeea;">&#8594;</span> f (t a)
<span style="color: #c678dd;">dist</span> <span style="color: #dcaeea;">=</span> traverse id
</pre>
</div>

<p>
There&rsquo;s no need to show the Scala because we can reply on the implementations in
the Cats library, but the instance implementations for list are as above. In the
paper we see that you can also traverse more complex structures such as a
tree&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #c678dd;">sealed</span> <span style="color: #51afef;">trait</span> <span style="color: #ECBE7B;">Tree</span>[+<span style="color: #a9a1e1;">A</span>]
<span style="color: #51afef;">case</span> <span style="color: #51afef;">object</span> <span style="color: #a9a1e1;">Leaf</span> <span style="color: #51afef;">extends</span> <span style="color: #ECBE7B;">Tree</span>[<span style="color: #a9a1e1;">Nothing</span>]
<span style="color: #51afef;">case</span> <span style="color: #51afef;">class</span> <span style="color: #ECBE7B;">Node</span>[<span style="color: #a9a1e1;">A</span>](left<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Tree</span>[<span style="color: #a9a1e1;">A</span>], a<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">A</span>, right<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Tree</span>[<span style="color: #a9a1e1;">A</span>]) <span style="color: #51afef;">extends</span> <span style="color: #ECBE7B;">Tree</span>[<span style="color: #a9a1e1;">A</span>]

<span style="color: #51afef;">def</span> <span style="color: #c678dd;">treeTraverse</span>[<span style="color: #a9a1e1;">A</span>, <span style="color: #a9a1e1;">B</span>, <span style="color: #a9a1e1;">F</span>[<span style="color: #51afef;">_</span>]](f<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">A</span> <span style="color: #51afef;">=&gt;</span> <span style="color: #a9a1e1;">F</span>[<span style="color: #a9a1e1;">B</span>], fs<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Tree</span>[<span style="color: #a9a1e1;">A</span>])
                (<span style="color: #c678dd;">implicit</span> app<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Applicative</span>[<span style="color: #a9a1e1;">F</span>])<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">F</span>[<span style="color: #a9a1e1;">Tree</span>[<span style="color: #a9a1e1;">B</span>]] <span style="color: #51afef;">=</span> {
  fs <span style="color: #51afef;">match</span> {
    <span style="color: #51afef;">case</span> <span style="color: #a9a1e1;">Leaf</span> <span style="color: #51afef;">=&gt;</span>
      app.pure(<span style="color: #a9a1e1;">Leaf</span>)
    <span style="color: #51afef;">case</span> <span style="color: #ECBE7B;">Node</span>(<span style="color: #dcaeea;">left</span>, <span style="color: #dcaeea;">a</span>, <span style="color: #dcaeea;">right</span>) <span style="color: #51afef;">=&gt;</span>
      <span style="color: #51afef;">val</span> <span style="color: #dcaeea;">w1</span> <span style="color: #51afef;">=</span> app.pure((l<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Tree</span>[<span style="color: #a9a1e1;">B</span>]) <span style="color: #51afef;">=&gt;</span>
        (v<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">B</span>) <span style="color: #51afef;">=&gt;</span>
        (r<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Tree</span>[<span style="color: #a9a1e1;">B</span>]) <span style="color: #51afef;">=&gt;</span> <span style="color: #a9a1e1;">Node</span>(l,v,r))
      <span style="color: #51afef;">val</span> <span style="color: #dcaeea;">w2</span> <span style="color: #51afef;">=</span> w1.ap(treeTraverse(f,left))
      <span style="color: #51afef;">val</span> <span style="color: #dcaeea;">w3</span> <span style="color: #51afef;">=</span> w2.ap(f(a))
      w3.ap(treeTraverse(f,right))
  }
}

<span style="color: #51afef;">val</span> <span style="color: #dcaeea;">tree1</span> <span style="color: #51afef;">=</span> <span style="color: #a9a1e1;">Node</span>(<span style="color: #a9a1e1;">Leaf</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #a9a1e1;">Node</span>(<span style="color: #a9a1e1;">Leaf</span>, <span style="color: #da8548; font-weight: bold;">5</span>, <span style="color: #a9a1e1;">Node</span>(<span style="color: #a9a1e1;">Leaf</span>, <span style="color: #da8548; font-weight: bold;">10</span>, <span style="color: #a9a1e1;">Leaf</span>)))
println(<span style="color: #98be65;">"treeTraverse: "</span> + treeTraverse((n<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Int</span>) <span style="color: #51afef;">=&gt;</span> <span style="color: #a9a1e1;">Option</span>(n + <span style="color: #da8548; font-weight: bold;">1</span>), tree1))
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">treeTraverse: Some(Node(Leaf,11,Node(Leaf,6,Node(Leaf,11,Leaf))))</span>
</pre>
</div>

<p>
Note that in your own code you would usually lean on the Traverse type class and
override some methods to provide your own implementations.
</p>

<p>
Another thing to highlight the expressive power of traverse is that we can use
it to do a <code>map</code> like a <code>~Functor</code> by using the Id (identity) Monad as our
effect type. The Id monad simply wraps a pure value and has no other effect, so
we can use it to map as follows&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">@</span> <span style="color: #a9a1e1;">List</span>[<span style="color: #a9a1e1;">Int</span>](<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #da8548; font-weight: bold;">3</span>).traverse((a<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Int</span>) <span style="color: #51afef;">=&gt;</span> (<span style="color: #da8548; font-weight: bold;">1</span> + a)<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Id</span>[<span style="color: #a9a1e1;">Int</span>])
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Id[List[Int]] = List(2, 3, 4)</span>
</pre>
</div>
</div>
</div>
</div>
