---
layout: post
title: Word numbers programming puzzle
date: '2007-09-22T09:44:00.000-07:00'
author: Justin
tags: [lisp, common-lisp]
modified_time: '2007-09-22T10:03:44.607-07:00'
blogger_id: tag:blogger.com,1999:blog-4777243148323391813.post-7302558058541195918
blogger_orig_url: http://justinsboringpage.blogspot.com/2007/09/word-numbers-programming-puzzle.html
---

Reading <a href="http://www.itasoftware.com/careers/puzzles07.html">Reddit</a> last week I came across an interesting programming puzzle.<br /><br /><a href="http://www.itasoftware.com/careers/puzzles07.html">http://www.itasoftware.com/careers/puzzles07.html</a><br /><br />I've written a straightforward Common Lisp solution which is pasted below. What is interesting about this problem, and what would make it a good interview question, is that coding up the basic solution as I have here only poses more problems.<br /><br />None of the Lisp environments I've tried have enough heap space to complete this problem, even though in terms of time complexity it is O(n). Judging by how long it takes to run on a few hundred thousand numbers, and then several million, it would take about 20 hours on my 2Ghz PC to solve for 1 billion numbers.<br /><br />Even if I used the file system to hold the numbers, assuming each number fits in 50 chars of text, 4 bytes for the value and a further 4 to hold the length of the string, that is still in the order of 50Gb. You would then need to sort that file a bit at a time in memory, using a merge sort, and finally do a linear run through the file until you get the 51,000,000,000nth number.<br /><br />Some clever folk have presented a more intelligent solution here...<br /><br /><a href="http://conway.rutgers.edu/%7Eccshan/wiki/blog/posts/WordNumbers1/">http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers1/</a><br /><br />Here is my solution so far:<br /><br /><pre><br />#|<br /> Word Numbers<br /><br />This is a partial solution to the problem found at http://www.itasoftware.com/careers/puzzles07.html<br />by Justin Heyes-Jones<br /><br />I say partial because it does actually work, and if you had a lisp environment with enough memory, it would finish <br />in about a day. But the real solution seems to be either to spot patterns so you don't have to generate and sort <br />all 1 billion numbers, or to use the file system to cope with what your computer memory cannot. <br /><br /> "If the integers from 1 to 999,999,999 are written as words, sorted alphabetically, and concatenated, what is the 51 billionth letter?"<br /><br />To be precise: if the integers from 1 to 999,999,999 are expressed in words<br />(omitting spaces, 'and', and punctuation[1]), and sorted alphabetically so that the first six integers are<br /><br />    * eight<br />    * eighteen<br />    * eighteenmillion<br />    * eighteenmillioneight<br />    * eighteenmillioneighteen<br />    * eighteenmillioneighteenthousand<br /><br />and the last is<br /><br />    * twothousandtwohundredtwo<br /><br />then reading top to bottom, left to right, the 28th letter completes the spelling of the integer "eighteenmillion".<br /><br />The 51 billionth letter also completes the spelling of an integer. Which one, and what is the sum of all the integers to that point?<br /><br />[1] For example, 911,610,034 is written "ninehundredelevenmillionsixhundredtenthousandthirtyfour"; 500,000,000 is written "fivehundredmillion"; 1,709 is written "onethousandsevenhundrednine".<br /><br />|#<br /><br />; (load (compile-file "wordnumbers.lisp"))<br />; (solve 999999999 51000000000) ; unlikely to finish unless you have a massive memory heap <br />; (solve 10 26) ; will work, but may not get you the job ;-)<br /><br />;;;; Utilities<br /><br />(defmacro with-string-words((str word) &body body)<br />  "Utility macro to iterate over a string and return each word (anything between spaces)"<br />  `(do* ((start 0 (if end (1+ end) nil))<br />         (end<br />          (position #\Space ,str :start 0)<br />          (if end (position #\Space ,str :start (1+ end)) nil))<br />         (,word (subseq ,str start end) (if start (subseq ,str start end) nil)))<br />       ((null start))<br />     ,@body))<br /><br />;;;; Numbers are stores as the number in words, the length of this string and finally the numeric value<br /><br />(defun get-words(lst)<br />  (first lst))<br /><br />(defun get-length(lst)<br />  (second lst))<br /><br />(defun get-value(lst)<br />  (third lst))<br /><br />(defun remove-and(str)<br />  "remove occurences of 'and' from a string"<br />  (let ((new-str (make-array 0 :element-type 'character :fill-pointer 0 :adjustable t)))<br />    (with-string-words (str word)<br />                (if (string/= "and" word)<br />                    (and<br />                     (setf new-str (concatenate 'string new-str word))<br />                     (setf new-str (concatenate 'string new-str " ")))))<br />    new-str))<br /><br />(defun char-space-or-hyphen-p(c)<br />  (if (or (char= #\Space c) (char= #\- c))<br />      t<br />      nil))<br />  <br />(defun remove-spaces-and-hyphens(str)<br />  "remove spaces and hyphens from a string"<br />  (remove-if #'char-space-or-hyphen-p str))<br /><br />(defun get-number-as-words(n)<br />  "Use common lisps built in English text number output"<br />  (format nil "~r" n))<br /><br />(defun get-numbers-as-word-list(n)<br />  "get the numbers from 1 to n and return as a list of strings and the lengths"<br />  "of each string as a list of three items, words, length of word string and" <br />  "actual numeric value"<br />  (loop for n from 1 to n collect<br />        (let* ((str (get-number-as-words n)) (len (length str)))<br />          (list (convert-text str) len n))))<br /><br />(defun compare-word-and-len(a b)<br />  "given a string, length pair compare on alphabetical order"<br />  (string< (get-words a) (get-words b)))<br /><br />(defun sort-number-word-list-alphabetically(lst)<br />  (sort lst #'compare-word-and-len))<br /><br />(defun convert-text(str)<br />  (remove-spaces-and-hyphens (remove-and str)))<br /><br />(defun get-number-from-letter-index(lst target-index)<br />  (do<br />   ((number 0 (1+ number))<br />    (index 0 (+ index (get-length (nth number lst)))))<br />   ((> number (1- (length lst))))<br />    (if (<= target-index (+ index (get-length (nth number lst))))<br />        (return-from get-number-from-letter-index number)))<br />  nil)<br /><br />(defun sum-to-n(lst n)<br />  (if (>= n 0)<br />      (+ (get-value (car lst))<br />         (sum-to-n (cdr lst) (1- n)))<br />      0))<br /><br />(defun solve(num n)<br />  "Solve the problem for 'num' numbers, finding character position n"<br />  (let ((lst<br />         (sort-number-word-list-alphabetically<br />          (get-numbers-as-word-list num))))<br />    (format t "Made list~%")<br />    (let ((number<br />           (get-number-from-letter-index lst n)))<br />      (format t "Found number~%")<br />      (let ((value (get-value (nth number lst))))<br />        (format t "Done.~%Number at character pos ~a is ~a. Sum to that number is ~a~%" n value (sum-to-n lst number))))))<br /><br /><br /></pre>
