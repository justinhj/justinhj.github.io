---
layout: post
title: What's Ap with zio-prelude?
date: '2020-08-02T00:00:00.000-08:00'
tags: [pure-functional-programming, cats, scala, applicative, monads, functors, zio]
---

<div id="outline-container-orgd701510" class="outline-2">
<h2 id="orgd701510">Introduction</h2>
<div class="outline-text-2" id="text-orgd701510">
<p>
Back in April I did a deep dive into <code>Applicative Functors</code> and produced a
lengthy blog post that explains the practical use of Applicatives in Scala, how
they are implemented and where these ideas came from. If you are not familiar
with functional programming in Scala using Cats, and the Applicative type class
in particular, I&rsquo;d recommend at least scanning the post below or checking out
one of the related talks in the links above.
</p>

<a href="/2020/04/04/whats-ap.html">What's Ap?</a>

<p>
It can be challenging to explain the implementation of Applicative in Scala, and
especially the <code>ap</code> operation itself, which as the following tweet points out,
relies on currying to do its work. You can see this in some of the example code
in my post where I translated Haskell from the original 2008 paper &ldquo;Applicative
Programming with Effects&rdquo; into Scala. The lack of implied currying in Scala makes
working with applicatives involve a bit more typing than in Haskell, and
operates in a way that many Scala programmers will not be familiar with.
</p>

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">For a decade, &#39;ap&#39; from Applicative has infected Scala code:<br><br>def ap[A, B](f: F[A =&gt; B], fa: F[A]): F[B]<br><br>Cryptic &amp; confusing, did you know the raison d&#39;Ãªtre of &#39;ap&#39; is Haskell&#39;s curried functions, not category theory?<br><br>Learn how we can do better! ðŸ‘‡<a href="https://t.co/IL2FnBbPOy">https://t.co/IL2FnBbPOy</a></p>&mdash; John A De Goes (@jdegoes) <a href="https://twitter.com/jdegoes/status/1288134300349718530?ref_src=twsrc%5Etfw">July 28, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>
Currying, although not used as often in Scala as Haskell, as an important part
of the language, and Scala programmers should probably become familiar with it.
</p>

<p>
<a href="https://docs.scala-lang.org/tour/multiple-parameter-lists.html">https://docs.scala-lang.org/tour/multiple-parameter-lists.html</a>
</p>

<p>
Is this criticism fair? In this post we&rsquo;ll check out the new type class encoding
that you will find in the new functional programming library <code>Zio-Prelude</code>, and
compare it with the established encoding and hierarchy that you will find in
Cats, and that was closely modelled on Haskell.
</p>

<p>
<a href="https://github.com/zio/zio-prelude">https://github.com/zio/zio-prelude</a>
</p>
</div>
</div>

<div id="outline-container-org035b1a0" class="outline-2">
<h2 id="org035b1a0">zio-prelude in a nutshell</h2>
<div class="outline-text-2" id="text-org035b1a0">
<p>
I&rsquo;ve only been aware of prelude for a couple of days, so I&rsquo;m not an expert by
any means. What I have learned so far is based on a recent talk at SF Scala for
which you can find the slides here:
</p>

<p>
<a href="https://www.slideshare.net/jdegoes/refactoring-functional-type-classes">https://www.slideshare.net/jdegoes/refactoring-functional-type-classes</a>
</p>

<p>
Unlike Scalaz and Cats, prelude was not initially a public project, and was
developed as part of John De Goes&rsquo; ongoing functional programming classes.
However it is now fully open sourced and the Scala community as a whole can take
part in the project.
</p>

<p>
As you&rsquo;ll see in the slide deck, the goals of prelude are the following:
</p>

<ul class="org-ul">
<li>Radical</li>
<li>Orthogonal</li>
<li>Principled</li>
<li>Scala-First</li>
<li>Minimal</li>
<li>Pragmatic</li>
<li>Accessible</li>
<li>Opinionated</li>
</ul>

<p>
The goals I find most compelling here are accessible and orthogonal. As an fp
advocate and educator, I am very interested in any steps towards greater
accessibility. The orthogonal part is also big, as I believe that composability is
one of the biggest wins of pure functional programs.
</p>
</div>
</div>

<div id="outline-container-orga5204d5" class="outline-2">
<h2 id="orga5204d5">Algebra not Category Theory</h2>
<div class="outline-text-2" id="text-orga5204d5">
<p>
With Cats, almost all of the concepts come from category theory. We have Monads,
Functors, Monoids, Monoidal Functors and so on. The idea with prelude is that
algebra is more familiar to us, as non-mathematician programmers, than category
theory. Algebra&rsquo;s are also more composable, so the idea is to start with a small
number of primitive things(?) and combining them into more powerful objects.
</p>

<p>
The big question that prelude puts out there is this; is Category Theory an
obstacle to adoption of pure functional programming, and would abstract algebra
be a better way to both introduce newcomers, and provide a better solution
overall to the problems and applications that Cats et al already address?
</p>
</div>
</div>

<div id="outline-container-orgbed8325" class="outline-2">
<h2 id="orgbed8325">Functor and Monad</h2>
<div class="outline-text-2" id="text-orgbed8325">
</div>
<div id="outline-container-orgac97a24" class="outline-3">
<h3 id="orgac97a24">Functors</h3>
<div class="outline-text-3" id="text-orgac97a24">
<p>
In my original post I introduce Functor and Monad as the gateway to Applicative.
Functor is a simple and beautiful thing, in that it allows us to combine pure
functions with &ldquo;effectful&rdquo; computations, mapping an F[A] to an F[B]. In prelude
Functor and Monad do not exist as first class entities, although we can see them
defined as type aliases as follows&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">type</span> <span style="color: #a9a1e1;">Functor</span>[<span style="color: #a9a1e1;">F</span>[+<span style="color: #51afef;">_</span>]] <span style="color: #51afef;">=</span> <span style="color: #a9a1e1;">Covariant</span>[<span style="color: #a9a1e1;">F</span>]
<span style="color: #51afef;">type</span> <span style="color: #a9a1e1;">Monad</span>[<span style="color: #a9a1e1;">F</span>[+<span style="color: #51afef;">_</span>]] <span style="color: #51afef;">=</span> <span style="color: #a9a1e1;">Covariant</span>[<span style="color: #a9a1e1;">F</span>] <span style="color: #51afef;">with</span> <span style="color: #ECBE7B;">IdentityFlatten</span>[<span style="color: #a9a1e1;">F</span>]
</pre>
</div>

<p>
In Cats the Functor type class is actually short for Covariant Functor. What
does that mean? First of all one of the best discussions of covariance in Scala
I know can be found here on the scala-lang.org site:
</p>

<p>
<a href="https://docs.scala-lang.org/tour/variances.html">https://docs.scala-lang.org/tour/variances.html</a>
</p>

<p>
But in essence a covariant type parameter for some type A (denoted +A), means
that you can pass the type or super types of the type as that parameter.
</p>

<p>
The Cats Functor is also covariant in that if you have a function that can map
an A to a B, you can map a higher kinded type F[A] to F[B] too using the
Covariant Functor.
</p>

<p>
In Cats a Functor is defined as a higher kinded type with a map function. In
Prelude a Functor is just something that implements the Covariant type and
follows its laws.
</p>

<p>
In other words although Functor has essentially changed names in Prelude, it is
very much the same as the Cats Functor&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a9a1e1;">List</span>(<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #da8548; font-weight: bold;">3</span>).map(a <span style="color: #51afef;">=&gt;</span> a + <span style="color: #da8548; font-weight: bold;">1</span>)
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">List[Int] = List(2, 3, 4)</span>
<span style="color: #a9a1e1;">Option</span>(<span style="color: #da8548; font-weight: bold;">1</span>).map(a <span style="color: #51afef;">=&gt;</span> a + <span style="color: #da8548; font-weight: bold;">1</span>)
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Option[Int] = Some(2)</span>
</pre>
</div>

<p>
There is an excellent post about variance and functors on the Typelevel site:
</p>

<p>
<a href="https://typelevel.org/blog/2016/02/04/variance-and-functors.html">https://typelevel.org/blog/2016/02/04/variance-and-functors.html</a>
</p>
</div>
</div>

<div id="outline-container-orga8284e4" class="outline-3">
<h3 id="orga8284e4">Monads</h3>
<div class="outline-text-3" id="text-orga8284e4">
<p>
In Cats we extend Functor with Applicative and add the <code>flatMap</code> operation to get
Monad. Applicative brings us both <code>ap</code> and <code>pure</code>. Leaving ap aside for the
moment, pure is the important ability to lift a pure value into the context of
some effect, represented as a higher kinded type.
</p>

<p>
Let&rsquo;s take a look at sequencing two Futures together using prelude. In
order to do that with Cats we would use the Monad flatmap operation.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">getUser</span>(email<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">String</span>)<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Future</span>[<span style="color: #a9a1e1;">User</span>] <span style="color: #51afef;">=</span> ???

<span style="color: #51afef;">def</span> <span style="color: #c678dd;">getAccountStatus</span>(id<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">String</span>)<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Future</span>[<span style="color: #a9a1e1;">AccountStatus</span>] <span style="color: #51afef;">=</span> ???

<span style="color: #51afef;">val</span> <span style="color: #dcaeea;">accountStatus</span> <span style="color: #51afef;">=</span> getUser(<span style="color: #98be65;">"bob@google.com"</span>)
  .flatMap(user <span style="color: #51afef;">=&gt;</span> getAccountStatus(user.accountId))
</pre>
</div>

<p>
In prelude you would do the same, since nothing overrides flatMap from ZIO or
the standard library, you can simply call flatMap, but you wouldn&rsquo;t be
exercising the new algebraic components that make up prelude, stay tuned.
</p>

<p>
Remember above that Monad is defined as the composition of IdentityFlatten and
Covariant. We already saw that Covariant is Functor and provides map (remember
that all Monad&rsquo;s are functors).
</p>

<p>
IdentityFlatten is the composition of prelude types Associative, Identity and
Flatten. Flatten is easy it just gives us the ability to flatten an effect from
an F[F[A]] to an F[A]. For example the somewhat contrived code below executes a
ZIO that is nested inside another, resulting in a ZIO[ZIO[A]]. We can use the
ZIO Flatten instance to flatten and run the effects&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">import</span> zio.<span style="color: #51afef;">_</span>
<span style="color: #51afef;">val</span> <span style="color: #dcaeea;">runtime</span> <span style="color: #51afef;">=</span> <span style="color: #a9a1e1;">Runtime</span>.default
<span style="color: #51afef;">val</span> <span style="color: #dcaeea;">effect</span> <span style="color: #51afef;">=</span> <span style="color: #a9a1e1;">ZIO</span>{putStrLn(<span style="color: #98be65;">"Hello!"</span>); <span style="color: #a9a1e1;">ZIO</span>.succeed(<span style="color: #da8548; font-weight: bold;">10</span>)}
runtime.unsafeRun(effect.flatten)
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Hello!</span>
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Int = 10</span>
</pre>
</div>

<p>
Whilst most types, including ZIO effects, Future, Option and List all have
flatMap, we <code>could</code> define it in terms of <code>Covariant</code> and <code>IdentityFlatten</code> as follows.
</p>


<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">flatMap</span>[<span style="color: #a9a1e1;">F</span>[+<span style="color: #51afef;">_</span>]<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Covariant</span> <span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">IdentityFlatten</span>, <span style="color: #a9a1e1;">A</span>, <span style="color: #a9a1e1;">B</span>](fa<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">F</span>[<span style="color: #a9a1e1;">A</span>])(fab<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">A</span> <span style="color: #51afef;">=&gt;</span> <span style="color: #a9a1e1;">F</span>[<span style="color: #a9a1e1;">B</span>])<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">F</span>[<span style="color: #a9a1e1;">B</span>] <span style="color: #51afef;">=</span> {
  fa.map(a <span style="color: #51afef;">=&gt;</span> fab(a)).flatten
}
</pre>
</div>

<p>
Monad also traditionally defines <code>pure</code>, a way to lift pure values into an effect
context. We can do that with Covariant&rsquo;s <code>map</code> and IdentityFlatten&rsquo;s <code>any</code>.
<code>any</code> summons an effect out of thin air for us, and we can then use map to sneak
our pure value into that effect. Whilst this seems a little tricky, it gives a
bit more flexibility. As Adam Fraser puts it, this &ldquo;also allows you to express
constraints on the types of values that can be injected through implementing
CovariantSubset instead of Covariant&rdquo;. Subsets were not featured in the
talk so I look forward to hearing more about that feature.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">pure</span>[<span style="color: #a9a1e1;">F</span>[+<span style="color: #51afef;">_</span>] <span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Covariant</span> <span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">IdentityFlatten</span>, <span style="color: #a9a1e1;">A</span>](a<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">A</span>)(<span style="color: #c678dd;">implicit</span> i <span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">IdentityFlatten</span>[<span style="color: #a9a1e1;">F</span>])<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">F</span>[<span style="color: #a9a1e1;">A</span>] <span style="color: #51afef;">=</span> {
  i.any.map(<span style="color: #51afef;">_</span> <span style="color: #51afef;">=&gt;</span> a)
}
pure[<span style="color: #a9a1e1;">Option</span>,<span style="color: #a9a1e1;">Int</span>](<span style="color: #da8548; font-weight: bold;">12</span>)
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Option[Int] = Some(12)</span>
pure[<span style="color: #a9a1e1;">List</span>,<span style="color: #a9a1e1;">String</span>](<span style="color: #98be65;">"Hello"</span>)
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">List[String] = List(Hello)</span>
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgfd417ef" class="outline-2">
<h2 id="orgfd417ef">Applicatives in Prelude</h2>
<div class="outline-text-2" id="text-orgfd417ef">
<p>
You can skip back to &lt;a href=&ldquo;/2020/04/04/whats-ap.html&rdquo;&gt;What&rsquo;s Ap?&lt;/a&gt; if you
need to and read about Applicative again, but lets see how life is without it.
</p>

<p>
In my original post we used the ap function to apply a function to an option
using the ap function. Whilst the purpose of this was to go to explain currying
so we can apply a function to multiple effects, as parameters, here let&rsquo;s just
replicated it with prelude.
</p>

<p>
In prelude the equivalent to Applicative is defined as follows.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">type</span> <span style="color: #a9a1e1;">Applicative</span>[<span style="color: #a9a1e1;">F</span>[+<span style="color: #51afef;">_</span>]] <span style="color: #51afef;">=</span> <span style="color: #a9a1e1;">Covariant</span>[<span style="color: #a9a1e1;">F</span>] <span style="color: #51afef;">with</span> <span style="color: #ECBE7B;">IdentityBoth</span>[<span style="color: #a9a1e1;">F</span>]
</pre>
</div>

<p>
Covariant should be familiar, it is Functor and gives us map. IdentityBoth is
Identity with AssociativeBoth.
</p>

<p>
Associative both is product from Cats. (product can be implemented with the ap
function from Applicative)
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #c678dd;">override</span> <span style="color: #51afef;">def</span> <span style="color: #c678dd;">product</span>[<span style="color: #a9a1e1;">A</span>, <span style="color: #a9a1e1;">B</span>](fa<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">F</span>[<span style="color: #a9a1e1;">A</span>], fb<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">F</span>[<span style="color: #a9a1e1;">B</span>])<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">F</span>[(<span style="color: #a9a1e1;">A</span>, <span style="color: #a9a1e1;">B</span>)] <span style="color: #51afef;">=</span>
  ap(map(fa)(a <span style="color: #51afef;">=&gt;</span> (b<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">B</span>) <span style="color: #51afef;">=&gt;</span> (a, b)))(fb)

<span style="color: #a9a1e1;">Applicative</span>[<span style="color: #a9a1e1;">Option</span>].product(<span style="color: #a9a1e1;">Option</span>(<span style="color: #da8548; font-weight: bold;">10</span>), <span style="color: #a9a1e1;">Option</span>(<span style="color: #da8548; font-weight: bold;">12</span>)).map{<span style="color: #51afef;">case</span> (<span style="color: #dcaeea;">a</span>,<span style="color: #dcaeea;">b</span>) <span style="color: #51afef;">=&gt;</span> a + b}
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Option[Int] = Some(22)</span>
</pre>
</div>

<p>
In prelude product is essentialy defined directly as AssociativeBoth which
implements a binary associative operator to combine two effects into an effect
containing a tuple, in other words product.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a9a1e1;">AssociativeBoth</span>[<span style="color: #a9a1e1;">Option</span>].both(<span style="color: #a9a1e1;">Option</span>(<span style="color: #da8548; font-weight: bold;">10</span>), <span style="color: #a9a1e1;">Option</span>(<span style="color: #da8548; font-weight: bold;">12</span>)).map{<span style="color: #51afef;">case</span> (<span style="color: #dcaeea;">a</span>,<span style="color: #dcaeea;">b</span>) <span style="color: #51afef;">=&gt;</span> a + b}
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">Option[Int] = Some(22)</span>
</pre>
</div>

<p>
Traditional Applicative requires map, ap and pure. We have map from
Covariant, the equivalent of ap using both from AssociativeBoth and pure uses
Identity just like with our Monad example&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">def</span> <span style="color: #c678dd;">pure</span>[<span style="color: #a9a1e1;">F</span>[+<span style="color: #51afef;">_</span>] <span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Covariant</span> <span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">IdentityBoth</span>, <span style="color: #a9a1e1;">A</span>](a<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">A</span>)(<span style="color: #c678dd;">implicit</span> i <span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">IdentityBoth</span>[<span style="color: #a9a1e1;">F</span>])<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">F</span>[<span style="color: #a9a1e1;">A</span>] <span style="color: #51afef;">=</span> {
  i.any.map(<span style="color: #51afef;">_</span> <span style="color: #51afef;">=&gt;</span> a)
}
pure[<span style="color: #a9a1e1;">Option</span>,<span style="color: #a9a1e1;">Int</span>](<span style="color: #da8548; font-weight: bold;">12</span>)
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">res1: Option[Int] = Some(12)</span>
pure[<span style="color: #a9a1e1;">List</span>,<span style="color: #a9a1e1;">String</span>](<span style="color: #98be65;">"Hello"</span>)
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">res2: List[String] = List(Hello)</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org6dbf1c3" class="outline-2">
<h2 id="org6dbf1c3">Sequence and Traverse</h2>
<div class="outline-text-2" id="text-org6dbf1c3">
<p>
In the seminal paper Applicative programming with Effects, the first motivating
example for applicative programming is the sequence function. You have a list of
effects, specifically Haskell IO effects, and you would like to turn them into
an IO[List[A]]. You might recognise this as having the same shape and purpose as
Future.sequence from the Scala standard library. sequence is built with its more
powerful friend traverse.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a9a1e1;">Future</span>.sequence is a function <span style="color: #a9a1e1;">IterableOnce</span>[<span style="color: #a9a1e1;">Future</span>[<span style="color: #a9a1e1;">A</span>]] <span style="color: #51afef;">=&gt;</span> <span style="color: #a9a1e1;">Future</span>[<span style="color: #a9a1e1;">IterableOnce</span>[<span style="color: #a9a1e1;">A</span>]]
<span style="color: #a9a1e1;">Future</span>.traverse is a function <span style="color: #a9a1e1;">IterableOnce</span>[<span style="color: #a9a1e1;">A</span>], <span style="color: #a9a1e1;">A</span> <span style="color: #51afef;">=&gt;</span> <span style="color: #a9a1e1;">Future</span>[<span style="color: #a9a1e1;">B</span>] <span style="color: #51afef;">=&gt;</span> <span style="color: #a9a1e1;">Future</span>[<span style="color: #a9a1e1;">IterableOnce</span>[<span style="color: #a9a1e1;">B</span>]]
</pre>
</div>

<p>
In Typelevel Cats, the Traverse typeclass makes this more flexible by allows us
to traverse over any type that is a functor (you can map over it) and foldable
(you can fold it with foldLeft, foldRight and fold).
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">trait</span> <span style="color: #ECBE7B;">Traverse</span>[<span style="color: #a9a1e1;">F</span>[<span style="color: #51afef;">_</span>]] <span style="color: #51afef;">extends</span> <span style="color: #ECBE7B;">Functor</span>[<span style="color: #a9a1e1;">F</span>] <span style="color: #51afef;">with</span> <span style="color: #ECBE7B;">Foldable</span>[<span style="color: #a9a1e1;">F</span>] {
 <span style="color: #51afef;">def</span> <span style="color: #c678dd;">traverse</span>[<span style="color: #a9a1e1;">G</span>[<span style="color: #51afef;">_</span>]<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Applicative</span>, <span style="color: #a9a1e1;">A</span>, <span style="color: #a9a1e1;">B</span>](fa<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">F</span>[<span style="color: #a9a1e1;">A</span>])(f<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">A</span> <span style="color: #51afef;">=&gt;</span> <span style="color: #a9a1e1;">G</span>[<span style="color: #a9a1e1;">B</span>])<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">G</span>[<span style="color: #a9a1e1;">F</span>[<span style="color: #a9a1e1;">B</span>]]
}
</pre>
</div>


<p>
What&rsquo;s interesting about Traverse is that it relies on a number of type classes
to build its expressive power. Ultimately our little friend <code>ap</code> is the king pin
of the whole thing, allowing us to combine the effects together as we fold in a
way that is &ldquo;idiomatic&rdquo; to the effect type. When we traverse a list of Id for
example (the identity monad) we get map, and when we traverse a list of Const,
we get fold. In other words changing the data type is all we need to make
drastically different programs.
</p>

<p>
To demonstrate this in my applicative post, I wrote an implementation of a silly
algorithm called Sleep Sort. Sleep Sort works by waiting an amount of time based
on the value of the number. Emitting the numbers in this way sorts them
(assuming your scheduler is accurate enough). Let&rsquo;s be clear, this is a stupid
way to sort numbers, but it does represent some real world needs we have like
being able to run effects in parallel.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">import</span> zio.<span style="color: #51afef;">_</span>
<span style="color: #51afef;">import</span> zio.prelude.<span style="color: #51afef;">_</span>
<span style="color: #51afef;">import</span> zio.console.<span style="color: #51afef;">_</span>
<span style="color: #51afef;">import</span> zio.clock.<span style="color: #51afef;">_</span>
<span style="color: #51afef;">def</span> <span style="color: #c678dd;">delayedPrintNumber</span>(s<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">Int</span>)<span style="color: #51afef;">:</span> <span style="color: #ECBE7B;">ZIO</span>[<span style="color: #a9a1e1;">Console</span> <span style="color: #51afef;">with</span> <span style="color: #ECBE7B;">Clock</span>,<span style="color: #a9a1e1;">String</span>,<span style="color: #a9a1e1;">Int</span>] <span style="color: #51afef;">=</span> {
    putStrLn(s<span style="color: #98be65;">"Preparing to say number in </span><span style="color: #dcaeea;">$s</span><span style="color: #98be65;"> seconds"</span>) *&gt;
    putStrLn(s<span style="color: #98be65;">"</span><span style="color: #dcaeea;">$s</span><span style="color: #98be65;">"</span>).delay(s.seconds) *&gt;
    <span style="color: #a9a1e1;">ZIO</span>.succeed(s)
}
<span style="color: #51afef;">val</span> <span style="color: #dcaeea;">ios</span> <span style="color: #51afef;">=</span> <span style="color: #a9a1e1;">List</span>(<span style="color: #da8548; font-weight: bold;">6</span>,<span style="color: #da8548; font-weight: bold;">5</span>,<span style="color: #da8548; font-weight: bold;">2</span>,<span style="color: #da8548; font-weight: bold;">1</span>,<span style="color: #da8548; font-weight: bold;">3</span>,<span style="color: #da8548; font-weight: bold;">8</span>,<span style="color: #da8548; font-weight: bold;">4</span>,<span style="color: #da8548; font-weight: bold;">7</span>).map(delayedPrintNumber)
<span style="color: #5B6268;">// </span><span style="color: #5B6268;">ios: List[ZIO[Console with Clock,String,Int]]</span>
</pre>
</div>

<p>
Using Cats we can use Traverse.sequence to flip the List[Zio] to ZIO[List] and
then execute it.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">import</span> cats.__
<span style="color: #51afef;">import</span> cats.<span style="color: #a9a1e1;">Traverse</span>
<span style="color: #51afef;">val</span> <span style="color: #dcaeea;">runtime</span> <span style="color: #51afef;">=</span> <span style="color: #a9a1e1;">Runtime</span>.default
<span style="color: #51afef;">val</span> <span style="color: #dcaeea;">program</span> <span style="color: #51afef;">=</span> <span style="color: #a9a1e1;">Traverse</span>[<span style="color: #a9a1e1;">List</span>].traverse(ios)
runtime.unsafeRun(program)
</pre>
</div>

<p>
Sadly we find this does not work because wanted all the effects to start at once
and then complete at their alloted times, making the sort work. Instead we&rsquo;ll
see each executed in sequence.
</p>

<pre class="example">
Monadic version

Preparing to say number in 6 seconds
6
Preparing to say number in 5 seconds
5
// ... and so on for a while
</pre>

<p>
Happily thanks to the joys of Applicative we can fix this by changing the data
type. If we rewrite using Cats Effect we wrap our IO into a different type
called Par.IO which has a different implementation of applicative that does NOT
sequence the IOs together but allows them to run in parallel, we can get the
sleep sort behaviour. We didn&rsquo;t change the structure of our code, just the data
type!
</p>

<p>
Now all of the effects started at the same time and ran in parallel.
</p>

<pre class="example">
Preparing to say number in 6 seconds
Preparing to say number in 2 seconds
Preparing to say number in 1 seconds
Preparing to say number in 3 seconds
Preparing to say number in 8 seconds
Preparing to say number in 4 seconds
Preparing to say number in 7 seconds
Preparing to say number in 5 seconds
1
2
3
4
5
6
7
8
</pre>
</div>
</div>

<div id="outline-container-orgc3c3611" class="outline-2">
<h2 id="orgc3c3611">ZIO Effects and Prelude</h2>
<div class="outline-text-2" id="text-orgc3c3611">
<p>
Let&rsquo;s visit the same problem using our ZIO effects above. One thing I like about
prelude is how combinations of its algebras are mapped to ZIO effects. In this
table we have two ZIO effects <code>fa : ZIO[R, E, A]</code> and <code>fb : ZIO[R, E, B]</code> that
are combined in different ways just by changing the algebra.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Algebra</th>
<th scope="col" class="org-left">ZIO instance implementation</th>
<th scope="col" class="org-left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">AssociativeBoth</td>
<td class="org-left">fa zip fb</td>
<td class="org-left">fa first then fb iff fa succeeds, returning ZIO[R,E,(A,B)]</td>
</tr>

<tr>
<td class="org-left">AssociativeEither</td>
<td class="org-left">fa.orElseEither(fb)</td>
<td class="org-left">fa first then if it fails fb, returning ZIO[R,E,Either[A,B]]</td>
</tr>

<tr>
<td class="org-left">CommutativeBoth</td>
<td class="org-left">fa zipPar fb</td>
<td class="org-left">fa and fb at the same time, returning ZIO[R,E,(A,B)]</td>
</tr>
</tbody>
</table>

<p>
This is really nice and similar in spirit to what we did with Cats Traverse.
</p>

<p>
ZIO&rsquo;s implementation of Traverse has eschewed conventional names for some
functions in favour or more common words, so for example sequence is just flip,
which describes the flipping of the F[G[A]] to a G[F[A]]. We should be able to
just flip our list of ZIOs and execute them using traverse.
</p>

<p>
However, when we come back to Traverable prelude&rsquo;s (version of Traverse) there
are two difficulties.
</p>
</div>

<div id="outline-container-org0ff1788" class="outline-3">
<h3 id="org0ff1788">Problem 1. Traversable doesn&rsquo;t handle empty structures</h3>
<div class="outline-text-3" id="text-org0ff1788">
<p>
Perhaps by design, you cannot just take a list of ZIO effects and Traverse them,
because the flip function requires the G parameter to have the IdentityBoth
algebra. That algebra lets us combine two effects to a tuple, and there is an
identity element. ZIO effects do not have an instance of the IdentityBoth
algebra and as such cannot be used with Traverable.
</p>

<p>
We can get around this by using the NonEmptyTraversable which implements the
Traversable type class for non empty structures. Its functions are postfixed
with a 1 to indicate they require at least one element to work with, and use
AssociativeBoth algebra which ZIO has as you can see above.
</p>
</div>
</div>

<div id="outline-container-org856a85f" class="outline-3">
<h3 id="org856a85f">Problem 2. We don&rsquo;t have a way to change from sequenced to parallel execution</h3>
<div class="outline-text-3" id="text-org856a85f">
<p>
When we were dealing with Applicatives we can change the data type to select a
different applicative and get a different combining method. This is a crucial
part of Traverse IMHO. This functionality is missing because the algebra is
hardcoded. We can&rsquo;t used the Algebra of choice from the table above (we would
need to use CommutativeBoth to get the parallel execution the sleep sort needs).
</p>
</div>
</div>

<div id="outline-container-org913850c" class="outline-3">
<h3 id="org913850c">Running the code</h3>
<div class="outline-text-3" id="text-org913850c">
<div class="org-src-container">
<pre class="src src-scala"><span style="color: #51afef;">val</span> <span style="color: #dcaeea;">runtime</span> <span style="color: #51afef;">=</span> <span style="color: #a9a1e1;">Runtime</span>.default
runtime.unsafeRun(<span style="color: #a9a1e1;">NonEmptyTraversable</span>[<span style="color: #a9a1e1;">NonEmptyList</span>].flip1(ios))
</pre>
</div>

<p>
Sadly the best we can do at the moment is to use flip1 but we are limited to
sequential execution.
</p>
</div>
</div>

<div id="outline-container-orgafe8880" class="outline-3">
<h3 id="orgafe8880">Solutions</h3>
<div class="outline-text-3" id="text-orgafe8880">
<p>
I talked to Adam Fraser about this and the probably solution will be a
forthcoming newtype called Parallel which can wrap your effects with. This would
work but feels a bit strange because we already had algebras that change
behaviours but we can&rsquo;t freely use them in this context, and having additional
newtypes seems like it violates the don&rsquo;t repeat yourself (DRY) prinicple.
</p>

<p>
Another possible solution would be to have additional Traverse types with
different algebras. Neither solution seems as clean as the Applicative one at
this point.
</p>
</div>
</div>
</div>

<div id="outline-container-org070c4f2" class="outline-2">
<h2 id="org070c4f2">Conclusion</h2>
<div class="outline-text-2" id="text-org070c4f2">
<p>
I&rsquo;ve been looking forward to prelude for a couple of months since I heard of its
existent on the grapevine. Overall there are some very nice aspects to the
library; the coherent and simple newtypes, the new ZPure (a swiss army knife of
useful monads in a box?) and the idea of composing your type classes from
small do one thing well algebras.
</p>

<p>
As zio-prelude evolves I expect it will at first grow, then shed some features
into modules or libraries, before shrinking to a smaller but coherent core.
</p>

<p>
I also predict it will create further bifurcation in the Scala FP community. As
it becomes more tightly integrated with ZIO it will surely attract some ZIO
programmers to give prelude their attention. For beginners there is now another
choice for developing FP skills; learn the Haskell-motivated original type class
encoding, or start with the prelude way. There&rsquo;s not a lot of overlap between
the two.
</p>
</div>
</div>

<div id="outline-container-orgeb59f74" class="outline-2">
<h2 id="orgeb59f74">References</h2>
<div class="outline-text-2" id="text-orgeb59f74">
</div>
<div id="outline-container-org3eb0866" class="outline-3">
<h3 id="org3eb0866">Videos</h3>
<div class="outline-text-3" id="text-org3eb0866">
<ul class="org-ul">
<li><a href="https://youtu.be/OwmHgL9F_9Q">SF Scala: Reimagining Functional Type Classes</a></li>
<li><a href="https://youtu.be/_LDk9BU_Rmc">What&rsquo;s ap?</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgd19ec33" class="outline-3">
<h3 id="orgd19ec33">Code</h3>
<div class="outline-text-3" id="text-orgd19ec33">
<ul class="org-ul">
<li><a href="https://github.com/justinhj/applicatives">applicatives</a> (Scala conversion from the paper and lots of Applicative stuff)</li>
<li><a href="https://github.com/zio/zio-prelude">zio-prelude</a> (A full on system for Monadic and Applicative programming)</li>
</ul>

<p>
&copy; 2020 Justin Heyes-Jones. All Rights Reserved.
</p>
</div>
</div>
</div>
