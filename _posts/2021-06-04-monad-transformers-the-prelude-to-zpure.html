---
layout: post
title: Monad Transformers - the prelude to ZPure
tags: [scala, scala-3, dotty, monads, category-theory]
---
<link rel="stylesheet" type="text/css" href="../../../_orgcss/site.css" />

<div style="padding: 30px;">
  <img class="img" src="../../../images/monadtransformers.png" border="1" alt="Diagram of monad transformers with the ZPure type" width="600"/>
</div>

<div id="outline-container-orga590fd5" class="outline-2">
<h2 id="orga590fd5">Readers and Writers and Transformers</h2>
<div class="outline-text-2" id="text-orga590fd5">
<p>
BTW you can check out the video here instead: 
<a href="https://youtu.be/tEnZZlOn-jI">Functional Justin - Another Angle on Monad Transformers</a>
</p>

<p>
There's 20 pages here or over an hour of videos, so let me help you decide if it's worth your time.
</p>
</div>

<div id="outline-container-org2fb6705" class="outline-3">
<h3 id="org2fb6705">Who are you?</h3>
<div class="outline-text-3" id="text-org2fb6705">
<p>
You are a Scala programmer or interested in Scala and may have some Haskell or interest in pure functional programming.
</p>
</div>
</div>

<div id="outline-container-org9288ae6" class="outline-3">
<h3 id="org9288ae6">What do I cover?</h3>
<div class="outline-text-3" id="text-org9288ae6">
<ul class="org-ul">
<li>Introduction to Monad transformers</li>
<li>Implement the WriterT monad in Scala 3 from scratch and used in a program</li>
<li>Implement the ReaderT monad in Scala 3, also from scratch, and use it</li>
<li>Why not both? Stack the Reader and Writer monads on top of each other</li>
<li>Effect rotation and ZIO Prelude's ZPure, another approach to combining effects</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-org36b4052" class="outline-2">
<h2 id="org36b4052">Evaluating expressions</h2>
<div class="outline-text-2" id="text-org36b4052">
<p>
In previous blogs and videos I've described a program that evaluates
arithmetic expressions as this is a nice testbed for various
functional effects. So far I've demonstrated how by using different
data types and type classes one can make the same program behave
differently.
</p>

<p>
This is important for a couple of reasons. It means that you can
compose interesting programs from smaller, well understood components,
and because we can understand and change the behaviour of our program
by using different types.
</p>

<p>
As a starting point lets begin with a version of the program that has
error handling using the Either data type and Numeric which is a
generic implementation of numbers.
</p>

<p>
If you didn't catch up on earlier posts let's recap. An example run of
the program requires an environment (symbol table) provided using the
Scala 3 implicit mechanism (using the given keyword). I call eval on a
sample expression tree which yields either a Right or a Left result
since I'm using Either as the result effect type.
</p>

<div class="org-src-container">
<pre class="src src-scala">  <span style="color: #b6a0ff;">given</span> envMap<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Env</span>[<span style="color: #00bcff;">Int</span>] <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">Map</span>(<span style="color: #79a8ff;">"x"</span> -&gt; <span style="color: #00bcff;">7</span>, <span style="color: #79a8ff;">"y"</span> -&gt; <span style="color: #00bcff;">6</span>, <span style="color: #79a8ff;">"z"</span> -&gt; <span style="color: #00bcff;">22</span>)

  <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">exp1</span> <span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">Int</span>] <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">Mul</span>(<span style="color: #00bcff;">Var</span>(<span style="color: #79a8ff;">"z"</span>), <span style="color: #00bcff;">Add</span>(<span style="color: #00bcff;">Val</span>(<span style="color: #00bcff;">10</span>), <span style="color: #00bcff;">Sub</span>(<span style="color: #00bcff;">Var</span>(<span style="color: #79a8ff;">"x"</span>), <span style="color: #00bcff;">Var</span>(<span style="color: #79a8ff;">"y"</span>))))

  <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">eval1</span> <span style="color: #b6a0ff;">=</span> eval(exp1)

  println(s<span style="color: #79a8ff;">"Eval exp gives </span><span style="color: #00d3d0;">$eval1</span><span style="color: #79a8ff;">"</span>)

<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">[info] running Scala3EvalEither </span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Eval exp gives Right(242)</span>

</pre>
</div>

<p>
I represent the errors as a Scala 3 enum which is a nice way to create
ADT's (algebraic data types), similar to how you would do it in Rust.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">enum</span> <span style="color: #00bcff;">EvalError</span> {
  <span style="color: #b6a0ff;">case</span> <span style="color: #00bcff;">InvalidSymboName</span>
  <span style="color: #b6a0ff;">case</span> <span style="color: #00bcff;">SymbolNotFound</span>
  <span style="color: #b6a0ff;">case</span> <span style="color: #00bcff;">DivisionByZero</span>
}
</pre>
</div>

<p>
The next things to look at are an ADT to represent the program steps a return type.
</p>

<div class="org-src-container">
<pre class="src src-scala">
<span style="color: #b6a0ff;">enum</span> <span style="color: #00bcff;">Exp</span>[<span style="color: #00bcff;">A</span>]<span style="color: #b6a0ff;">:</span>
  <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Val</span>(<span style="color: #00d3d0;">value</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">A</span>) <span style="color: #b6a0ff;">extends</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>]
  <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Add</span>(<span style="color: #00d3d0;">left</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>], <span style="color: #00d3d0;">right</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>]) <span style="color: #b6a0ff;">extends</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>]
  <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Sub</span>(<span style="color: #00d3d0;">left</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>], <span style="color: #00d3d0;">right</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>]) <span style="color: #b6a0ff;">extends</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>]
  <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Mul</span>(<span style="color: #00d3d0;">left</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>], <span style="color: #00d3d0;">right</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>]) <span style="color: #b6a0ff;">extends</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>]
  <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Div</span>(<span style="color: #00d3d0;">left</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>], <span style="color: #00d3d0;">right</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>]) <span style="color: #b6a0ff;">extends</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>]
  <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Var</span>(<span style="color: #00d3d0;">identifier</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">String</span>) <span style="color: #b6a0ff;">extends</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>]

<span style="color: #b6a0ff;">type</span> <span style="color: #00bcff;">Env</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">Map</span>[<span style="color: #00bcff;">String</span>, <span style="color: #00bcff;">A</span>]

<span style="color: #b6a0ff;">import</span> <span style="color: #00bcff;">Exp</span>.<span style="color: #b6a0ff;">_</span>

<span style="color: #b6a0ff;">type</span> <span style="color: #00bcff;">WithEnv</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">Env</span>[<span style="color: #00bcff;">A</span>] ?=&gt; <span style="color: #00bcff;">Either</span>[<span style="color: #00bcff;">EvalError</span>, <span style="color: #00bcff;">A</span>]
</pre>
</div>

<p>
The <code>Env</code> type is a simple map for strings to values that we will use
as a symbol table so that variables can be looked up at runtime. The
<code>?-&gt;</code> syntax indicates that the return type is a context function. An
earlier blog discusses that, but in short it allows us to thread our
Env symbol table through the computation easily.
</p>

<p>
Here is the main body of the code.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">eval</span>[<span style="color: #00bcff;">A</span> <span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Numeric</span>](exp<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>])<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">WithEnv</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span>
  exp <span style="color: #b6a0ff;">match</span>
    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Var</span>(<span style="color: #00d3d0;">id</span>) <span style="color: #b6a0ff;">=&gt;</span> handleVar(id)
    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Val</span>(<span style="color: #00d3d0;">value</span>) <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">Right</span>(value)
    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Add</span>(<span style="color: #00d3d0;">l</span>,<span style="color: #00d3d0;">r</span>) <span style="color: #b6a0ff;">=&gt;</span> handleAdd(l,r)
    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Sub</span>(<span style="color: #00d3d0;">l</span>,<span style="color: #00d3d0;">r</span>) <span style="color: #b6a0ff;">=&gt;</span> handleSub(l,r)
    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Div</span>(<span style="color: #00d3d0;">l</span>,<span style="color: #00d3d0;">r</span>) <span style="color: #b6a0ff;">=&gt;</span> handleDiv(l,r)
    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Mul</span>(<span style="color: #00d3d0;">l</span>,<span style="color: #00d3d0;">r</span>) <span style="color: #b6a0ff;">=&gt;</span> handleMul(l,r)

<span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">handleAdd</span>[<span style="color: #00bcff;">A</span> <span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Numeric</span>](l<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>] , r<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>] )<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">WithEnv</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> eval(l) + eval(r)
<span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">handleSub</span>[<span style="color: #00bcff;">A</span> <span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Numeric</span>](l<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>] , r<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>] )<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">WithEnv</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> eval(l) - eval(r)
<span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">handleMul</span>[<span style="color: #00bcff;">A</span> <span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Numeric</span>](l<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>] , r<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>] )<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">WithEnv</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> eval(l) * eval(r)
<span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">handleDiv</span>[<span style="color: #00bcff;">A</span> <span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Numeric</span>](l<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>] , r<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>] )<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">WithEnv</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> eval(l) / eval(r)

<span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">handleVar</span>[<span style="color: #00bcff;">A</span>](s<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">String</span>)<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">WithEnv</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span>
  summonEnv.get(s) <span style="color: #b6a0ff;">match</span> {
    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Some</span>(<span style="color: #00d3d0;">value</span>) <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">Right</span>(value)
    <span style="color: #b6a0ff;">case</span> <span style="color: #00bcff;">None</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">Left</span>(<span style="color: #00bcff;">EvalError</span>.<span style="color: #00bcff;">SymbolNotFound</span>)
  }
</pre>
</div>

<p>
Those arithmetic operators you see are operating not on integers,
doubles or some other concrete type, but are working on a type A that
has a Numeric instance. You may wonder then how that <code>+</code> operator
knows what to do? The answer is that I implemented an instance of
Numeric for the type <code>Numeric[Either[EvalError,A]]</code>.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Implement Numeric for EvalResult</span>
<span style="color: #b6a0ff;">given</span> evalResultNumeric[<span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Numeric</span>]<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Numeric</span>[<span style="color: #00bcff;">Either</span>[<span style="color: #00bcff;">EvalError</span>, <span style="color: #00bcff;">A</span>]] <span style="color: #b6a0ff;">with</span> {

  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">add</span>(fa<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">EvalResult</span>[<span style="color: #00bcff;">A</span>], fb<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">EvalResult</span>[<span style="color: #00bcff;">A</span>])<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">EvalResult</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> {
    fa.map2(fb)((a,b) <span style="color: #b6a0ff;">=&gt;</span> a + b)
  }
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">... and so on</span>
}
</pre>
</div>

<p>
Whilst this is a lot of overhead for a simple program, as your
programs scale in complexity, this level of abstraction lets you
control effects as well as swap them in and out as your requirements
change without having to rewrite the core logic.
</p>

<p>
As an example, let's introduce a Monad Transformer and show how to
integrate it with the program above.
</p>
</div>
</div>

<div id="outline-container-orge92bcca" class="outline-2">
<h2 id="orge92bcca">WriterT</h2>
<div class="outline-text-2" id="text-orge92bcca">
<p>
Let's say we want to take an existing effectful program and add a new
effect to it. The effect I will demonstrate is logging. There is a
data type called Writer which represents a value and a log. 
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00bcff;">Writer</span>[<span style="color: #00bcff;">W</span>,<span style="color: #00bcff;">A</span>](run<span style="color: #b6a0ff;">:</span> (<span style="color: #00bcff;">W</span>,<span style="color: #00bcff;">A</span>))
</pre>
</div>

<p>
This is not very interesting on its own but if you make a program from
Writers, sequencing them together using the Monad's flatMap operation
for example, then the end result consists of a final value and a log
for <code>each step of the program</code>.
</p>

<p>
But since I already comitted to using Either, if I change the type to
Writer then I would lose the ability to handle errors. Instead what I
want is to keep the Either effect and <code>wrap</code> it with the capability of
the Writer monad.
</p>

<p>
Monad transformers are the answer. Now the trouble with monads is that
they don't compose manually together. As I covered in a previous blog,
applicatives do. You can take any two applicative effects such as
Either and List and compose them with a simple compose functions. 
</p>

<p>
With Monads the composition of any particular monad has to be
hand-crafted, so if I want to stack a Reader on top of an Either,
which I do, then I need to implement a ReaderT (reader transformer).
</p>

<p>
It only needs to be implented once and for all and can then be applied
to any other Monad (not just for Either). The idea is to make an
implementation of Reader that wraps another Monadic data type.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">WriterT</span>[<span style="color: #00bcff;">F</span>[<span style="color: #b6a0ff;">_</span>],<span style="color: #00bcff;">W</span>,<span style="color: #00bcff;">A</span>](<span style="color: #f78fe7;">private</span> <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">wrapped</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">F</span>[(<span style="color: #00bcff;">W</span>,<span style="color: #00bcff;">A</span>)])
</pre>
</div>

<p>
Here you can see the definition of the WriterT data type. The
difference between WriterT and Writer is that the WriterT wraps an
existing monad. Note that there is no need to constrain the
higher-kinded type F to be a Monad, but later on when we use it in
various ways it is possible to constrain F to be a Functor,
Applicative or Monad depending on the use-case. Choosing the type
bounds that constrain what the wrapped type must support based on the
individual functions needs gives you more flexibility.
</p>

<p>
For example if you have a data type that has a map operation but no
meaningful way to make a flatMap, you can still use the Monad
transformer as long as you only use Functor level methods.
</p>
</div>

<div id="outline-container-org70ad577" class="outline-3">
<h3 id="org70ad577">Lifting</h3>
<div class="outline-text-3" id="text-org70ad577">
<p>
In order to use WriterT there needs to be a mechanism to take your
inner data type (Either in this case) and make an instance of WriterT.
That can be done like this in my implementation by using the WriterT
constructor. For example let's say we have an Either instance we can
transform it to a WriterT like this.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">e1</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Either</span>[<span style="color: #00bcff;">EvalError</span>,<span style="color: #00bcff;">Int</span>] <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">Right</span>(<span style="color: #00bcff;">10</span>)
<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">w1</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">WriterT</span>(e1.map(n <span style="color: #b6a0ff;">=&gt;</span> (<span style="color: #00bcff;">List</span>.empty[<span style="color: #00bcff;">String</span>], n)))
</pre>
</div>

<p>
It's not straightforward because the WriterT wrapped type must be
<code>F[(W,A)]</code> and we had an F[A]. That is why I need to use the map
operation to take any value the Either may have and combine it with an
empty log. Here we assume the log is a list of strings and Scala is
able to infer that too.
</p>

<p>
Since this needed often the lift method is often added which takes
care of creating an empty log message and mapping it for us.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">object</span> <span style="color: #00bcff;">WriterT</span><span style="color: #b6a0ff;">:</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">lift</span>[<span style="color: #00bcff;">F</span>[<span style="color: #b6a0ff;">_</span>],<span style="color: #00bcff;">W</span>, <span style="color: #00bcff;">A</span>](fa<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">F</span>[<span style="color: #00bcff;">A</span>])(<span style="color: #b6a0ff;">using</span> m<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Monoid</span>[<span style="color: #00bcff;">W</span>], <span style="color: #00bcff;">F</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Functor</span>[<span style="color: #00bcff;">F</span>])<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">WriterT</span>[<span style="color: #00bcff;">F</span>,<span style="color: #00bcff;">W</span>,<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span>
    <span style="color: #00bcff;">WriterT</span>(<span style="color: #00bcff;">F</span>.map(fa)(a <span style="color: #b6a0ff;">=&gt;</span> (m.zero, a)))

<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">... </span>

  <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">e1</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Either</span>[<span style="color: #00bcff;">EvalError</span>,<span style="color: #00bcff;">Int</span>] <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">Right</span>(<span style="color: #00bcff;">10</span>)
  <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">w1</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">WriterT</span>[[<span style="color: #00bcff;">A</span>] =&gt;&gt; <span style="color: #00bcff;">Either</span>[<span style="color: #00bcff;">EvalError</span>,<span style="color: #00bcff;">A</span>],<span style="color: #00bcff;">List</span>[<span style="color: #00bcff;">String</span>],<span style="color: #00bcff;">Int</span>] <span style="color: #b6a0ff;">=</span> 
    <span style="color: #00bcff;">WriterT</span>.lift(e1)
</pre>
</div>

<p>
Couple of interesting things to note about the lift method type
signature. For one you can see that the log must be a Monoid. A Monoid
is a type that must have two useful operations that make it useful for
logs: It must be able to produce an empty element of whatever type it
is specialized for, and it must be able to join that type together.
</p>

<p>
This gives the user the flexibility to use any data type for the log
and not have to worry about providing an empty log or an append
function. The example here is a monoid since it is a list of
strings. We can obviously produce an empty list easily, and the append
function is also trivial, so if you look at my Monoid instance for
lists you can see the implementation is trivial.
</p>

<p>
Another interesting thing is the Functor type constraint. As I
mentioned above, although we call them Monad transformers, they can be
used with Functors, Applicatives and Monads. Since the lift function
only needs map, it needs only the Functor type constraint.
</p>
</div>
</div>

<div id="outline-container-org9d03e19" class="outline-3">
<h3 id="org9d03e19">Evaluating expressions with a log</h3>
<div class="outline-text-3" id="text-org9d03e19">
<p>
Now I'll walk through the changes needed to convert the expression
evaluator from having the return type Either, to being one of
WriterT[Either]
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Without log</span>
<span style="color: #b6a0ff;">type</span> <span style="color: #00bcff;">WithEnv</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">Env</span>[<span style="color: #00bcff;">A</span>] ?=&gt; <span style="color: #00bcff;">Either</span>[<span style="color: #00bcff;">EvalError</span>, <span style="color: #00bcff;">A</span>]
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">With log</span>
<span style="color: #b6a0ff;">type</span> <span style="color: #00bcff;">WithEnv</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">Env</span>[<span style="color: #00bcff;">A</span>] ?=&gt; <span style="color: #00bcff;">WriterT</span>[[<span style="color: #00bcff;">A1</span>] =&gt;&gt; <span style="color: #00bcff;">Either</span>[<span style="color: #00bcff;">EvalError</span>, <span style="color: #00bcff;">A1</span>], <span style="color: #00bcff;">List</span>[<span style="color: #00bcff;">String</span>], <span style="color: #00bcff;">A</span>]
</pre>
</div>

<p>
The next step is to make small changes to my programs implementation
to manage this new type. As you can see, the simplest change, handling
a basic numeric value, just involves lifting our original Either and
adding a log entry.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span class="linenr">1: </span><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">eval</span>[<span style="color: #00bcff;">A</span> <span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Numeric</span>](exp<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>])<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">WithEnv</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span>
<span class="linenr">2: </span>  exp <span style="color: #b6a0ff;">match</span>
<span class="linenr">3: </span>    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Var</span>(<span style="color: #00d3d0;">id</span>) <span style="color: #b6a0ff;">=&gt;</span> handleVar(id)
<span class="linenr">4: </span>    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Val</span>(<span style="color: #00d3d0;">value</span>) <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">WriterT</span>.lift[[<span style="color: #00bcff;">A1</span>] =&gt;&gt; <span style="color: #00bcff;">EvalResult</span>[<span style="color: #00bcff;">A1</span>], <span style="color: #00bcff;">List</span>[<span style="color: #00bcff;">String</span>], <span style="color: #00bcff;">A</span>](<span style="color: #00bcff;">Right</span>(value)).tell(<span style="color: #00bcff;">List</span>(s<span style="color: #79a8ff;">"Val </span><span style="color: #00d3d0;">$value</span><span style="color: #79a8ff;">"</span>))
<span class="linenr">5: </span>    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Add</span>(<span style="color: #00d3d0;">l</span>,<span style="color: #00d3d0;">r</span>) <span style="color: #b6a0ff;">=&gt;</span> handleAdd(l,r)
<span class="linenr">6: </span>    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Sub</span>(<span style="color: #00d3d0;">l</span>,<span style="color: #00d3d0;">r</span>) <span style="color: #b6a0ff;">=&gt;</span> handleSub(l,r)
<span class="linenr">7: </span>    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Div</span>(<span style="color: #00d3d0;">l</span>,<span style="color: #00d3d0;">r</span>) <span style="color: #b6a0ff;">=&gt;</span> handleDiv(l,r)
<span class="linenr">8: </span>    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Mul</span>(<span style="color: #00d3d0;">l</span>,<span style="color: #00d3d0;">r</span>) <span style="color: #b6a0ff;">=&gt;</span> handleMul(l,r)
</pre>
</div>

<p>
You can see in line 4 the code is a matter of lifting the value
wrapped in an Either. The type annotation is needed and creates some
noise.  I use the tell function to add a log entry for this step.
</p>

<p>
<code>tell</code> is a method on the WriterT data type itself, and it takes
advantage of the log types monoid to combine this new log entry with
any prior ones. 
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">tell</span>(l1<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">W</span>)(<span style="color: #b6a0ff;">using</span> m<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Monoid</span>[<span style="color: #00bcff;">W</span>], f<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Functor</span>[<span style="color: #00bcff;">F</span>])<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">WriterT</span>[<span style="color: #00bcff;">F</span>,<span style="color: #00bcff;">W</span>,<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span>
  <span style="color: #00bcff;">WriterT</span>(wrapped.map{
    (l2,a) <span style="color: #b6a0ff;">=&gt;</span>
      (m.combine(l2, l1), a)
  })
</pre>
</div>

<p>
By this technique at the end of a computation we
should see a log of entries.
</p>

<p>
For example the expression <code>Val(10)</code> would be logged as <code>"Val
10"</code>. Having a step-by-step log of your application has various uses
including the following.
</p>

<ol class="org-ol">
<li>Debugging. View the state of your computation in detail</li>
<li>Auditing and statistics. Analyze the log of your computation for business information.</li>
<li>Restore a failed computation. You can log at each step enough information to resume an expensive computation that may have been interrupted.</li>
</ol>

<p>
These kind of benefits come with traditional logging, but building it
into your application in a pure and type rich way can amplify the
benefits.
</p>

<p>
Let's take a look at the symbol table lookup part of the program.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">handleVar</span>[<span style="color: #00bcff;">A</span>](s<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">String</span>)<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">WithEnv</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span>
  summonEnv.get(s) <span style="color: #b6a0ff;">match</span> {
    <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Some</span>(<span style="color: #00d3d0;">value</span>) <span style="color: #b6a0ff;">=&gt;</span> {
      <span style="color: #00bcff;">WriterT</span>.lift[[<span style="color: #00bcff;">A1</span>] =&gt;&gt; <span style="color: #00bcff;">Either</span>[<span style="color: #00bcff;">EvalError</span>,<span style="color: #00bcff;">A1</span>],<span style="color: #00bcff;">List</span>[<span style="color: #00bcff;">String</span>],<span style="color: #00bcff;">A</span>](<span style="color: #00bcff;">Right</span>(value)).tell(<span style="color: #00bcff;">List</span>(s<span style="color: #79a8ff;">"Var </span><span style="color: #00d3d0;">$s</span><span style="color: #79a8ff;"> (</span><span style="color: #00d3d0;">$value</span><span style="color: #79a8ff;">)"</span>))
    }
    <span style="color: #b6a0ff;">case</span> <span style="color: #00bcff;">None</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">WriterT</span>.lift(<span style="color: #00bcff;">Left</span>(<span style="color: #00bcff;">EvalError</span>.<span style="color: #00bcff;">SymbolNotFound</span>))
  }
</pre>
</div>

<p>
Again the change is virtually mechanical. We lifted our old code and
added the tell call to add some logging information. When we view
variable lookups in the log you will see something like <code>Var("x")</code>
written as <code>Var x (7)</code> where 7 is its value in the symbol table.
</p>
</div>
</div>

<div id="outline-container-org6c7d993" class="outline-3">
<h3 id="org6c7d993">Extending numeric</h3>
<div class="outline-text-3" id="text-org6c7d993">
<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">handleAdd</span>[<span style="color: #00bcff;">A</span> <span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Numeric</span>](l<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>] , r<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>] )<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">WithEnv</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> eval(l) + eval(r)
</pre>
</div>

<p>
The remainder of the program involves expressions like this one. We
use the <code>+</code> operator to add two other expressions together. How that
works is a combination of operator overloading, extension methods and
implementing an implicit implementation of Numeric for our new WriterT
return type.
</p>

<p>
Here I'm defining an implicit instance of Numeric that handles things
are Writers around Eithers. In previous posts this is where I first
implemented addition for different types of number, and then added the
ability to handle errors in a type safe and functional manner.
</p>

<p>
I'm just extending that technique to handle a more complicated type.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">given</span> evalResultWNumeric[<span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Numeric</span>]<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Numeric</span>[<span style="color: #00bcff;">WriterT</span>[[<span style="color: #00bcff;">A1</span>] =&gt;&gt; <span style="color: #00bcff;">Either</span>[<span style="color: #00bcff;">EvalError</span>, <span style="color: #00bcff;">A1</span>], <span style="color: #00bcff;">List</span>[<span style="color: #00bcff;">String</span>], <span style="color: #00bcff;">A</span>]] <span style="color: #b6a0ff;">with</span>
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">... implementations</span>
</pre>
</div>

<p>
The implementation of Add assuming a Monadic instance is available is as follows.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">M</span> <span style="color: #b6a0ff;">=</span> writerTMonad[[<span style="color: #00bcff;">A1</span>] =&gt;&gt; <span style="color: #00bcff;">Either</span>[<span style="color: #00bcff;">EvalError</span>,<span style="color: #00bcff;">A1</span>], <span style="color: #00bcff;">List</span>[<span style="color: #00bcff;">String</span>]]

<span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">add</span>(fa<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">EvalResultW</span>[<span style="color: #00bcff;">A</span>], fb<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">EvalResultW</span>[<span style="color: #00bcff;">A</span>])<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">EvalResultW</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> {
    <span style="color: #00bcff;">M</span>.flatMap(fa) {
      a <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">M</span>.map(fb){
        b <span style="color: #b6a0ff;">=&gt;</span>
          a + b
      }
    } <span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">EvalResultW</span>[<span style="color: #00bcff;">A</span>]
  }
</pre>
</div>

<p>
Which does the job but it doesn't include any logging. We can add that too.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">add</span>(fa<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">EvalResultW</span>[<span style="color: #00bcff;">A</span>], fb<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">EvalResultW</span>[<span style="color: #00bcff;">A</span>])<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">EvalResultW</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> {
    <span style="color: #00bcff;">M</span>.flatMap(fa) {
      a <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">M</span>.flatMap(fb){
        b <span style="color: #b6a0ff;">=&gt;</span>
          <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">result</span> <span style="color: #b6a0ff;">=</span> a + b 
          <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">w1</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">EvalResultW</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">WriterT</span>.lift(<span style="color: #00bcff;">Right</span>(result))
          w1.tell(<span style="color: #00bcff;">List</span>(s<span style="color: #79a8ff;">"Added </span><span style="color: #00d3d0;">$a</span><span style="color: #79a8ff;"> and </span><span style="color: #00d3d0;">$b</span><span style="color: #79a8ff;"> giving </span><span style="color: #00d3d0;">$result</span><span style="color: #79a8ff;">"</span>))
      }
    }
  }
</pre>
</div>

<p>
Note that by nesting the flatMaps we have access to a,b and the result
of the computation so we can put all of that into the tell call,
resulting in a log like <code>Added 22 and 23 giving 45</code>.
</p>

<p>
There's nothing really wrong with this implementation, but it's
important to always think about the priniciple of least power. Did I
really need a Monad here? Well in fact there is a great function for
applying a computation across two different effects and that is
<code>map2</code>. It also requires only Applicative, so I can use that instead.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">App</span> <span style="color: #b6a0ff;">=</span> writerTApplicative[[<span style="color: #00bcff;">A1</span>] =&gt;&gt; <span style="color: #00bcff;">Either</span>[<span style="color: #00bcff;">EvalError</span>,<span style="color: #00bcff;">A1</span>], <span style="color: #00bcff;">List</span>[<span style="color: #00bcff;">String</span>]]

 <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">add</span>(fa<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">EvalResultW</span>[<span style="color: #00bcff;">A</span>], fb<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">EvalResultW</span>[<span style="color: #00bcff;">A</span>])<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">EvalResultW</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> {
   <span style="color: #00bcff;">App</span>.map2(fa)(fb) {
     <span style="color: #b6a0ff;">case</span> (<span style="color: #00d3d0;">a</span>,<span style="color: #00d3d0;">b</span>) <span style="color: #b6a0ff;">=&gt;</span> a + b
   }
 }
</pre>
</div>

<p>
This simplifies the code greatly but notice that I am no longer
logging anything. Unfortunately, I no longer have access to the result
of the computation. One clean solution I found here was to write a
helper method that is like a logging version of map2. Like map2 it
takes a function of two arguments to map the effect values, but it
takes a second function that takes the two values and their result and
let's you build a log entry from them.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">mapTell2</span>[<span style="color: #00bcff;">A</span>,<span style="color: #00bcff;">B</span>,<span style="color: #00bcff;">C</span>,<span style="color: #00bcff;">F</span>[<span style="color: #b6a0ff;">_</span>],<span style="color: #00bcff;">W</span>](fa<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">WriterT</span>[<span style="color: #00bcff;">F</span>,<span style="color: #00bcff;">W</span>,<span style="color: #00bcff;">A</span>],fb<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">WriterT</span>[<span style="color: #00bcff;">F</span>,<span style="color: #00bcff;">W</span>,<span style="color: #00bcff;">B</span>],fabc<span style="color: #b6a0ff;">:</span> (<span style="color: #00bcff;">A</span>,<span style="color: #00bcff;">B</span>) <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">C</span>,fabcw<span style="color: #b6a0ff;">:</span> (<span style="color: #00bcff;">A</span>,<span style="color: #00bcff;">B</span>,<span style="color: #00bcff;">C</span>) <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">W</span>)
                           (<span style="color: #b6a0ff;">using</span> m<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Monoid</span>[<span style="color: #00bcff;">W</span>], f<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Monad</span>[<span style="color: #00bcff;">F</span>])<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">WriterT</span>[<span style="color: #00bcff;">F</span>,<span style="color: #00bcff;">W</span>,<span style="color: #00bcff;">C</span>] <span style="color: #b6a0ff;">=</span> {
   <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">r</span> <span style="color: #b6a0ff;">=</span> fa.unwrap().map2(fb.unwrap()){
     <span style="color: #b6a0ff;">case</span> ((<span style="color: #00d3d0;">al</span>,<span style="color: #00d3d0;">a</span>),(<span style="color: #00d3d0;">bl</span>,<span style="color: #00d3d0;">b</span>)) <span style="color: #b6a0ff;">=&gt;</span>
       <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">c</span> <span style="color: #b6a0ff;">=</span> fabc(a,b)
       <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">w</span> <span style="color: #b6a0ff;">=</span> fabcw(a,b,c)
       <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">prev</span> <span style="color: #b6a0ff;">=</span> m.combine(al,bl)
       (m.combine(prev,w),c)
   }
   <span style="color: #00bcff;">WriterT</span>(r)
 }
</pre>
</div>

<p>
While this looks like a handful what it is really doing is
straightforward. Like map2 the input is two effects. First I unwrap
them which gives us the inner effect, and running map2 on those gives
the log and the value of each effect.
</p>

<p>
Once I've run the user function fabc on those values, I have the
result value c and I can use that to build a log with the fabcw
function. Finally we need to combine the prior logs with the new log
and return the result.
</p>

<p>
Here's the function in action.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">sub</span>(a<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">EvalResultW</span>[<span style="color: #00bcff;">A</span>], b<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">EvalResultW</span>[<span style="color: #00bcff;">A</span>])<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">EvalResultW</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> {
     mapTell2(a,b,(a, b) <span style="color: #b6a0ff;">=&gt;</span> a / b,(a,b,c) <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">List</span>(s<span style="color: #79a8ff;">"</span><span style="color: #00d3d0;">$c</span><span style="color: #79a8ff;">: subtracted </span><span style="color: #00d3d0;">$a</span><span style="color: #79a8ff;"> from </span><span style="color: #00d3d0;">$b</span><span style="color: #79a8ff;">"</span>))
}
</pre>
</div>

<p>
By moving all that complexity into a helper function, each operator is now quite simple.
</p>

<pre class="example">
[info] running Scala3EvalEitherTWriter 
WriterT(Right((List(Var y (6), Var x (7), Val 10, Var z (22)),45)))
Var y (6)
Var x (7)
Val 10
Var z (22)
exp01 WriterT(Left(DivisionByZero))
</pre>

<p>
In summary, you can use WriterT to convert any effectful program into
one with step-by-step logging.
</p>
</div>
</div>
</div>

<div id="outline-container-orgfb53321" class="outline-2">
<h2 id="orgfb53321">ReaderT</h2>
<div class="outline-text-2" id="text-orgfb53321">
<p>
Another useful data type with a Monad instance is the Reader. As the
name may imply, this is the conceptual opposite of Writer. i.e.,
instead a computation writing its progress to a log, the Reader
provides an environment of some type that the application can read
from as it progresses.
</p>

<p>
In the program so far I've been using Scala 3 context functions to
pass around the symbol table. There are reasons you may want to do
that with a Reader instead. Perhaps you want to take advantage of the
compositionality and lawfulness of Reader. Perhaps you want the
context function reserved for some other purpose. Of course you may be
using Scala 2 and not have access to the context function feature at
all.
</p>

<p>
In one of my videos I show the process of replacing context functions
with the ReaderT monad transformer. Let's walk through the process
here.
</p>

<p>
First of all let's look at the data type. Like the WriterT, the
ReaderT wraps another higher kinded type F. As you can see, there is a
second type parameter R, which is the type of the read-only
environment. Also you can see from the signature is that what the
ReaderT contains is a function from R to the F[A]. How that is used
will become clear.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">case</span> <span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">ReaderT</span>[<span style="color: #00bcff;">F</span>[<span style="color: #b6a0ff;">_</span>],<span style="color: #00bcff;">R</span>,<span style="color: #00bcff;">A</span>](run<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">R</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">F</span>[<span style="color: #00bcff;">A</span>])
</pre>
</div>

<p>
Just like with WriterT we also would benefit from a lift function that
let's us take any instance of F and wrap it. Here I'm saying if you
have some effect <code>F[A]</code> I will give you a ReaderT that wraps it. You
can run it with some environment and it will yield that <code>F[A]</code> again.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">object</span> <span style="color: #00bcff;">ReaderT</span><span style="color: #b6a0ff;">:</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">lift</span>[<span style="color: #00bcff;">F</span>[<span style="color: #b6a0ff;">_</span>],<span style="color: #00bcff;">R</span>,<span style="color: #00bcff;">A</span>](fa<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">F</span>[<span style="color: #00bcff;">A</span>])<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">ReaderT</span>[<span style="color: #00bcff;">F</span>,<span style="color: #00bcff;">R</span>,<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">ReaderT</span>(<span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> fa)
</pre>
</div>

<p>
When rewriting the program above we can now lookup variables from the
symbol table. We are returning a function that when given an
environment can search it for the required symbol. 
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">handleVar</span>[<span style="color: #00bcff;">A</span>](s<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">String</span>)<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">RResult</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span>
   <span style="color: #00bcff;">ReaderT</span>((env<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Env</span>[<span style="color: #00bcff;">A</span>]) <span style="color: #b6a0ff;">=&gt;</span>
     env.get(s) <span style="color: #b6a0ff;">match</span> {
       <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Some</span>(<span style="color: #00d3d0;">value</span>) <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">Right</span>(value)
       <span style="color: #b6a0ff;">case</span> <span style="color: #00bcff;">None</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">Left</span>(<span style="color: #00bcff;">EvalError</span>.<span style="color: #00bcff;">SymbolNotFound</span>)
     })
</pre>
</div>

<p>
Literal values are also simple, just lift the Either from before.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Val</span>(<span style="color: #00d3d0;">value</span>) <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">ReaderT</span>.lift(<span style="color: #00bcff;">Right</span>(value))
</pre>
</div>

<p>
The arithmetic operations don't change at all since ReaderT has an
applicative instance we can just go ahead and use map2.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">add</span>(fa<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">EvalResult</span>[<span style="color: #00bcff;">A</span>], fb<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">EvalResult</span>[<span style="color: #00bcff;">A</span>])<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">EvalResult</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> {
    fa.map2(fb)((a,b) <span style="color: #b6a0ff;">=&gt;</span> a + b)
  }
</pre>
</div>

<p>
Here is what needs to be done to run the code. The main difference is
that we build a chain of Reader effects then execute them by passing
an environment to the run method.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">env1</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Env</span>[<span style="color: #00bcff;">Int</span>] <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">Map</span>(<span style="color: #79a8ff;">"x"</span> -&gt; <span style="color: #00bcff;">1</span>, <span style="color: #79a8ff;">"y"</span> -&gt; <span style="color: #00bcff;">10</span>, <span style="color: #79a8ff;">"z"</span> -&gt; <span style="color: #00bcff;">100</span>)
<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">exp1</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">Add</span>(<span style="color: #00bcff;">Mul</span>(<span style="color: #00bcff;">Val</span>(<span style="color: #00bcff;">10</span>), <span style="color: #00bcff;">Var</span>(<span style="color: #79a8ff;">"y"</span>)),<span style="color: #00bcff;">Var</span>(<span style="color: #79a8ff;">"z"</span>))
println(eval(exp1).run(env1)) 

<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">Right(100))</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orga677d25" class="outline-2">
<h2 id="orga677d25">WriterT and ReaderT</h2>
<div class="outline-text-2" id="text-orga677d25">
<div style="padding: 30px;">
  <img class="img" src="../../../images/monadtransformer.png" border="1" alt="Diagram of monad transformers" width="600"/>
</div>

<p>
One thing I find wonderful about functional programming is the
compositionality. I've shown that you can stack WriterT and ReaderT on
top of any effect to imbue that effect with more capabilities.
</p>

<p>
Now given that WriterT can wrap a monadic effect to give that effect
logging, and further that ReaderT itself is a monad, it follows that
you can wrap WriterT around ReaderT to give some effect the powers of
both! This would work the other way around, and of course you could
also make an EitherT monad transformer, giving even more
possibilities.
</p>

<p>
The next step is to change the programs return type to be&#x2026;
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #00bcff;">WriterT</span>[
  [<span style="color: #00bcff;">RA</span>] =&gt;&gt; <span style="color: #00bcff;">ReaderT</span>[[<span style="color: #00bcff;">EA</span>] =&gt;&gt; <span style="color: #00bcff;">Either</span>[<span style="color: #00bcff;">EvalError</span>, <span style="color: #00bcff;">EA</span>], <span style="color: #00bcff;">Env</span>[<span style="color: #00bcff;">A</span>],<span style="color: #00bcff;">RA</span>],
  <span style="color: #00bcff;">List</span>[<span style="color: #00bcff;">String</span>],
  <span style="color: #00bcff;">A</span>]
</pre>
</div>

<p>
Next to modify the program to handle the new effect types.
</p>

<p>
The implementation to get a value is easy enough. Starting from the
inside out the value is put into an Either, lifted into ReaderT and
lifted once more into WriterT.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Val</span>(<span style="color: #00d3d0;">value</span>) <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">WriterT</span>.lift(
     <span style="color: #00bcff;">ReaderT</span>.lift(
       <span style="color: #00bcff;">Right</span>(value))).tell(<span style="color: #00bcff;">List</span>(s<span style="color: #79a8ff;">"Literal value </span><span style="color: #00d3d0;">$value</span><span style="color: #79a8ff;">"</span>))
</pre>
</div>

<p>
Handling variable lookup we take care of the lookup first then wrap
that into a writer.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">handleVar</span>[<span style="color: #00bcff;">A</span>](s<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">String</span>)<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">WriterT</span>[[<span style="color: #00bcff;">RA</span>] =&gt;&gt; <span style="color: #00bcff;">ReaderT</span>[[<span style="color: #00bcff;">EA</span>] =&gt;&gt; <span style="color: #00bcff;">Either</span>[<span style="color: #00bcff;">EvalError</span>, <span style="color: #00bcff;">EA</span>], <span style="color: #00bcff;">Env</span>[<span style="color: #00bcff;">A</span>],<span style="color: #00bcff;">RA</span>],<span style="color: #00bcff;">List</span>[<span style="color: #00bcff;">String</span>],<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span>
  <span style="color: #00bcff;">WriterT</span>(<span style="color: #00bcff;">ReaderT</span>((env<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Env</span>[<span style="color: #00bcff;">A</span>]) <span style="color: #b6a0ff;">=&gt;</span>
    env.get(s) <span style="color: #b6a0ff;">match</span> {
      <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Some</span>(<span style="color: #00d3d0;">value</span>) <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">Right</span>(<span style="color: #00bcff;">List</span>(s<span style="color: #79a8ff;">"Looked up var </span><span style="color: #00d3d0;">$s</span><span style="color: #79a8ff;"> (</span><span style="color: #00d3d0;">$value</span><span style="color: #79a8ff;">)"</span>),value)
      <span style="color: #b6a0ff;">case</span> <span style="color: #00bcff;">None</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">Left</span>(<span style="color: #00bcff;">EvalError</span>.<span style="color: #00bcff;">SymbolNotFound</span>)
  }))
</pre>
</div>

<p>
I'll skip the rest of the program since the theme is the same; wrap
the reader code with the writer code and you're done. Let's take a
look at how to run the program.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">envMap</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Env</span>[<span style="color: #00bcff;">Int</span>] <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">Map</span>(<span style="color: #79a8ff;">"x"</span> -&gt; <span style="color: #00bcff;">7</span>, <span style="color: #79a8ff;">"y"</span> -&gt; <span style="color: #00bcff;">6</span>, <span style="color: #79a8ff;">"z"</span> -&gt; <span style="color: #00bcff;">22</span>)

<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">eval1</span> <span style="color: #b6a0ff;">=</span> eval(exp1).unwrap().run(envMap)

eval1.foreach {
  (log, value) <span style="color: #b6a0ff;">=&gt;</span>
    println(s<span style="color: #79a8ff;">"Result is </span><span style="color: #00d3d0;">$value\n</span><span style="color: #79a8ff;">"</span>)
    log.foreach {
      println(<span style="color: #b6a0ff;">_</span>)
    }
}
</pre>
</div>

<p>
Here you can see that our program has to be run sort of inside
out. <code>eval(exp1)</code> gives us a <code>WriterT</code>. By calling <code>unwrwap</code> I get the
<code>ReaderT</code> inside it, which I can then run by passing the environment.
</p>

<p>
The response is either an error or a tuple of our log and result,
which we can then iterate over to print it out.
</p>

<pre class="example">
Result is 990

Looked up var z (22)
Literal value 10
Literal value 2
Divided 10 by 2 (5)
Literal value 2
Subtracted 2 from 5 (3)
Looked up var x (7)
Looked up var y (6)
Multiplied 7 by 6 (42)
Added 3 to 42 (45)
Multiplied 22 by 45 (990)

</pre>
</div>
</div>

<div id="outline-container-orgd577892" class="outline-2">
<h2 id="orgd577892">Monad Transformers - some takeaways</h2>
<div class="outline-text-2" id="text-orgd577892">
<p>
You can see that monad transformers offer some expressive power since
they allow us to manually combine different effect types to get the
benefit of them all at once. 
</p>

<p>
This comes at significant cost though. All this nesting creates
additional JVM objects that take up heap space and may cause extra
work for the garbage collector. 
</p>

<p>
For the programmer the ergnomics are not great. You have to remember
the level of nesting you're at at each point of your program and make
sure to do the right amount of lifting.
</p>

<p>
(Just realized I've missed out on a lot of "Do you even lift bro?"
memery in this post, but it's too late now and perhaps that's for the
best.)
</p>

<p>
Just look at this single simple expression. So much space is taken up
by the type signature, all the simplicity and elegance is lost.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">handleAdd</span>[<span style="color: #00bcff;">A</span> <span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Numeric</span>](l<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>] , r<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Exp</span>[<span style="color: #00bcff;">A</span>] )<span style="color: #b6a0ff;">:</span> 
  <span style="color: #00bcff;">WriterT</span>[[<span style="color: #00bcff;">RA</span>] =&gt;&gt; 
    <span style="color: #00bcff;">ReaderT</span>[[<span style="color: #00bcff;">EA</span>] =&gt;&gt; 
      <span style="color: #00bcff;">Either</span>[<span style="color: #00bcff;">EvalError</span>, <span style="color: #00bcff;">EA</span>], 
      <span style="color: #00bcff;">Env</span>[<span style="color: #00bcff;">A</span>],<span style="color: #00bcff;">RA</span>],
    <span style="color: #00bcff;">List</span>[<span style="color: #00bcff;">String</span>],
    <span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> eval(l) + eval(r)
</pre>
</div>

<p>
Now there ways to help out the Scala compiler and reduce the amount of
boilerplate, namely "kinda curried type parameters" which is a
technique used heavily in Scalaz and Zio.
</p>

<p>
<a href="https://tpolecat.github.io/2015/07/30/infer.html">https://tpolecat.github.io/2015/07/30/infer.html</a>
</p>

<p>
Thinking that maybe the poor type inference is maybe my fault I've
also written this code using Scalaz and Cats and you can see that each
implementation has its pros and cons. (BTW in these libraries ReaderT
is called Kleisli)
</p>

<p>
<a href="https://github.com/justinhj/ZPurePlay/blob/master/src/main/scala/EvalScalaz.scala">Reader Writer example in Scalaz</a>
</p>

<p>
<a href="https://github.com/justinhj/ZPurePlay/blob/master/src/main/scala/EvalCats.scala">Reader Writer example in Typelevel Cats</a>
</p>

<p>
Both implementations had the same problem as I did when not writing
out the types in full. Scalaz had the same trouble inferring that my
type was applicative so I had to summon the instance explicitly.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #f78fe7;">implicit</span> <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">rwApply</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">Apply</span>[<span style="color: #00bcff;">WriterT</span>[<span style="color: #00bcff;">List</span>[<span style="color: #00bcff;">String</span>],<span style="color: #00bcff;">Kleisli</span>[<span style="color: #00bcff;">Either</span>[<span style="color: #00bcff;">Error</span>,?],<span style="color: #00bcff;">Env</span>[<span style="color: #00bcff;">A</span>],?],?]]
rwApply.apply2(x,y) {
       <span style="color: #b6a0ff;">case</span> (<span style="color: #00d3d0;">a</span>,<span style="color: #00d3d0;">b</span>) <span style="color: #b6a0ff;">=&gt;</span> a + b
}
</pre>
</div>

<p>
Cats was able to handle it resulting in less code and needed less type
annotations in general.
</p>

<div class="org-src-container">
<pre class="src src-scala">x.map2(y) {
  <span style="color: #b6a0ff;">case</span> (<span style="color: #00d3d0;">a</span>,<span style="color: #00d3d0;">b</span>) <span style="color: #b6a0ff;">=&gt;</span> a + b
}
</pre>
</div>
</div>
</div>

<div id="outline-container-org9071c96" class="outline-2">
<h2 id="org9071c96">Effect rotation with Zio Prelude's ZPure</h2>
<div class="outline-text-2" id="text-org9071c96">
<p>
<a href="https://github.com/zio/zio-prelude">Zio Prelude</a> is a new library that acts as a sort of add on library to
<a href="https://github.com/zio/zio">ZIO</a> (a zero-dependency Scala library for asynchronous and concurrent
programming) which provides an alternative approach to functional
abstractions in Scala.
</p>

<p>
For the purposes of this blog I'm interested in particular
experimental data type within the library called <code>ZPure</code>. ZPure has 6
type parameters and supports the operations of monads, applicatives
and functors, albeit the names are changed and some of the
abstractions too.
</p>

<p>
From Prelude's own source code "<code>ZPure</code> can be used to model a variety
of effects including context, state, failure, and logging.", let's see
how it compares to monad transformers to implement the program above.
</p>

<p>
ZPure has six type parameters, which may seem like a lot, but bear in
mind that every time you combine monads you get more type parameters,
but they are stacked vertically not horizontally. With ZPure you start
with all the different effect types one might need but you don't need
to keep adding more and more, and you don't suffer from creating
multiple objects per layer of effect.
</p>

<div style="padding: 30px;">
  <img class="img" src="../../../images/zpure.png" border="1" alt="ZPure type parameters" width="600"/>
</div>

<p>
In the diagram the parameters are.
</p>

<ul class="org-ul">
<li><code>W</code> Logging. The type of logs that this effect produces, analagous to Writer</li>
<li><code>S</code> State. There are two S's because the type encodes an input and output state type</li>
<li><code>R</code> Reader. The type of the read-only environment</li>
<li><code>E</code> Error. The type of the error channel</li>
<li><code>A</code> Value. The type of the happy path computed value</li>
</ul>

<p>
Just as before all I need to do is change my programs effect type and
modify the implementation accordingly. The code for this section can
be found <a href="https://github.com/justinhj/ZPurePlay/blob/master/src/main/scala/EvalZpure.scala">here</a>.
</p>

<p>
Although Prelude supports Scala 3 now I rewrote my program in Scala 2
in order to do the Scalaz and Cats versions, so the following is also
pre Scala 3 friendly code. First I made a sealed trait to represent
the error types and an alias to indicate that my log will be
strings. 
</p>

<p>
Note that ZPure is opinionated about the logging type. In the more
conventional approach the log has to be a monoid instance. With ZPure
the log is handled using the ZIO <code>Chunk</code> data type which is a high
performance data structure with a pure functional interface. What that
means for us is that we can consider our log type as a single entity
and not worry about how it is appended.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #f78fe7;">sealed</span> <span style="color: #b6a0ff;">trait</span> <span style="color: #6ae4b9;">Error</span>
<span style="color: #b6a0ff;">object</span> <span style="color: #00bcff;">SymbolNotFound</span> <span style="color: #b6a0ff;">extends</span> <span style="color: #6ae4b9;">Error</span>
<span style="color: #b6a0ff;">object</span> <span style="color: #00bcff;">DivisionByZero</span> <span style="color: #b6a0ff;">extends</span> <span style="color: #6ae4b9;">Error</span>

<span style="color: #b6a0ff;">type</span> <span style="color: #00bcff;">Log</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">String</span>
</pre>
</div>

<p>
These types will represent the <code>E</code> or error, and <code>W</code> or log. We can
also encode our symbol table using the <code>R</code> parameter.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">type</span> <span style="color: #00bcff;">Env</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">Map</span>[<span style="color: #00bcff;">String</span>, <span style="color: #00bcff;">A</span>]
</pre>
</div>

<p>
The final type looks like this.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">type</span> <span style="color: #00bcff;">Result</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">ZPure</span>[<span style="color: #00bcff;">Log</span>, <span style="color: #00bcff;">Any</span>, <span style="color: #00bcff;">Any</span>, <span style="color: #00bcff;">Env</span>[<span style="color: #00bcff;">A</span>], <span style="color: #00bcff;">Error</span>, <span style="color: #00bcff;">A</span>]
</pre>
</div>

<p>
Note that I am not using the initial or updated state here so I use
Any for those parameters so as not to constrain them.
</p>

<p>
Once again lets start with the implementation of literal values.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Val</span>(<span style="color: #00d3d0;">value</span>) <span style="color: #b6a0ff;">=&gt;</span> 
  <span style="color: #00bcff;">ZPure</span>.succeed(value).log(s<span style="color: #79a8ff;">"Literal value </span><span style="color: #00d3d0;">$value</span><span style="color: #79a8ff;">"</span>)
</pre>
</div>

<p>
What's going on here is simple and refreshingly free of type
annotation. Firstly I construct a ZPure consisting of the literal
value, and then add a log using ZPure's log method. 
</p>

<p>
Now let's implement the symbol table lookup of variables.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span class="linenr"> 1: </span><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">handleVar</span>[<span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Numeric</span>](s<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">String</span>)<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Result</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> {
<span class="linenr"> 2: </span>    <span style="color: #00bcff;">ZPure</span>.environment[<span style="color: #00bcff;">Any</span>, <span style="color: #00bcff;">Env</span>[<span style="color: #00bcff;">A</span>]].flatMap {
<span class="linenr"> 3: </span>      env <span style="color: #b6a0ff;">=&gt;</span>
<span class="linenr"> 4: </span>       <span style="color: #00bcff;">ZPure</span>.fromOption(env.get(s)).
<span class="linenr"> 5: </span>       mapError(<span style="color: #b6a0ff;">_</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">EvalZPure</span>.<span style="color: #00bcff;">SymbolNotFound</span>).
<span class="linenr"> 6: </span>       flatMap{
<span class="linenr"> 7: </span>        a <span style="color: #b6a0ff;">=&gt;</span>
<span class="linenr"> 8: </span>          <span style="color: #00bcff;">ZPure</span>.log(s<span style="color: #79a8ff;">"Var </span><span style="color: #00d3d0;">$s</span><span style="color: #79a8ff;"> value </span><span style="color: #00d3d0;">$a</span><span style="color: #79a8ff;">"</span>).<span style="color: #b6a0ff;">as</span>(a)
<span class="linenr"> 9: </span>       }      
<span class="linenr">10: </span>    }
<span class="linenr">11: </span>}
</pre>
</div>

<p>
First I use the ZPure.environment to summon the symbol table and
flatMap over it so we can access it as a concrete value <code>env</code>.
</p>

<p>
Remember that looking up the variable in the symbol table
is going to return an Option since it is a normal map get. We can then
use the ZPure.fromOption to convert that to a ZPure.
</p>

<p>
We may be a ZPure at that point but we have the wrong error type. In
ZPure and option is simulated by yielding a success value A for Some,
or giving Unit in the error channel to indicate None. This reuse of
the error channel is neat, but since I would like a homogenous error
type for the program I need to convert that error channel from unit to
my own custom Error type. 
</p>

<p>
To do that I use mapError which takes a function to map the error from
one type to another.
</p>

<p>
The final step is to add a log. Since I would like the log to show
both the variable name and the actual value I have to nest it inside a
flatMap so we can access the success value. The last thing to note
here is the <code>as</code> which helps the type system make a ZPure of the right
type.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #f78fe7;">implicit</span> <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">numericZResult</span>[<span style="color: #00bcff;">A</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Numeric</span>]<span style="color: #b6a0ff;">:</span> 
  <span style="color: #00bcff;">Numeric</span>[<span style="color: #00bcff;">Result</span>[<span style="color: #00bcff;">A</span>]] <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">new</span> <span style="color: #6ae4b9;">Numeric</span>[<span style="color: #00bcff;">Result</span>[<span style="color: #00bcff;">A</span>]] {
    <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">add</span>(x<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Result</span>[<span style="color: #00bcff;">A</span>], y<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Result</span>[<span style="color: #00bcff;">A</span>])<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Result</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> {
      x.zip(y).flatMap{<span style="color: #b6a0ff;">case</span> (<span style="color: #00d3d0;">a</span>,<span style="color: #00d3d0;">b</span>) <span style="color: #b6a0ff;">=&gt;</span> 
        <span style="color: #00bcff;">ZPure</span>.succeed(a + b).log(s<span style="color: #79a8ff;">"Add </span><span style="color: #00d3d0;">$a</span><span style="color: #79a8ff;"> and </span><span style="color: #00d3d0;">$b</span><span style="color: #79a8ff;">"</span>)}
  }
  <span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">and so on</span>
</pre>
</div>

<p>
The final component is to make an instance of Numeric. Prelude takes
the approach to naming that concepts should be plain English where
possible, so it uses <code>succeed</code> instead of <code>pure</code> or <code>unit</code> and
similarly <code>zip</code> instead of applicative terminology.
</p>

<p>
That being the case, we use zip here to combine the left and right
side effects and apply the appropriate arithmetic operator.
</p>

<p>
So far so good, but we can't log the result of the computation. This
is easily solved.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">add</span>(x<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Result</span>[<span style="color: #00bcff;">A</span>], y<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Result</span>[<span style="color: #00bcff;">A</span>])<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Result</span>[<span style="color: #00bcff;">A</span>] <span style="color: #b6a0ff;">=</span> {
    x.zip(y).flatMap{<span style="color: #b6a0ff;">case</span> (<span style="color: #00d3d0;">a</span>,<span style="color: #00d3d0;">b</span>) <span style="color: #b6a0ff;">=&gt;</span>  {
      <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">result</span> <span style="color: #b6a0ff;">=</span> a + b
      <span style="color: #00bcff;">ZPure</span>.succeed(result).log(s<span style="color: #79a8ff;">"Add </span><span style="color: #00d3d0;">$a</span><span style="color: #79a8ff;"> and </span><span style="color: #00d3d0;">$b</span><span style="color: #79a8ff;"> (</span><span style="color: #00d3d0;">$result</span><span style="color: #79a8ff;">)"</span>)}
    }
  }
</pre>
</div>

<p>
The last part to note is the driver code to run the program.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">eval1</span> <span style="color: #b6a0ff;">=</span> eval(exp1).provide(env1).runAll()

eval1._2 <span style="color: #b6a0ff;">match</span> {
  <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Right</span>(<span style="color: #00d3d0;">value</span>) <span style="color: #b6a0ff;">=&gt;</span> 
    println(s<span style="color: #79a8ff;">"Succeeded with value </span><span style="color: #00d3d0;">${value._2}</span><span style="color: #79a8ff;">"</span>)
    eval1._1.foreach {
      l <span style="color: #b6a0ff;">=&gt;</span> 
        println(l)
  }
  <span style="color: #b6a0ff;">case</span> <span style="color: #6ae4b9;">Left</span>(<span style="color: #00d3d0;">err</span>) <span style="color: #b6a0ff;">=&gt;</span>
    println(s<span style="color: #79a8ff;">"oops! </span><span style="color: #00d3d0;">$err</span><span style="color: #79a8ff;">"</span>)
}
</pre>
</div>

<p>
Here I run eval to create the effect, provide to give it the runtime
environment and runAll. To be clear what eval does is not run a
program, but build a data structure of objects based on the ZPure
operations, and that data structure is evaluated in Prelude using an
efficient interpreter, that yields the result of the program, the log
and any state changes.
</p>

<pre class="example">
Succeeded with value 200
Literal value 10
Var x value 1
Mul 10 with 1 (10)
Var y value 10
Mul 10 with 10 (100)
Var z value 100
Add 100 and 100 (200)
</pre>
</div>
</div>

<div id="outline-container-org65b4994" class="outline-2">
<h2 id="org65b4994">Conclusion</h2>
<div class="outline-text-2" id="text-org65b4994">
<p>
In this post I implemented and motivated ReaderT and WriterT and
transforming monads to combine effects. Even in Haskell where they
originated, monad transformers come with caveats about performance and
ergonomics. In Scala they are not used often.
</p>

<p>
There are techniques and libraries to make their use more
convient. Although I have not used it <a href="https://github.com/typelevel/cats-mtl">Cats MTL</a> offers solutions to
some of the problems, but it is not widely used.
</p>

<p>
Although ZIO Prelude's ZPure is still somewhat experimental it seems
offer the benefits of monad transformers such as composability and a
prinicipled type safe api. But it is also much easier to work with and
anecdotally more performant on the JVM.
</p>

<p>
(C)2021 Justin Heyes-Jones, All Rights Reserved.
</p>
</div>
</div>
