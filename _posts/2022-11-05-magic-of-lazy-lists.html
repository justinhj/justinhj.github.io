---
layout: post
title: The Magic of Lazy Lists
tags: [pure-functional-programming, cats, scala, applicative, monads, comonads, kleisli, zio]
---
<link rel="stylesheet" type="text/css" href="../../../_orgcss/site.css" />

<style>
.img {
  width: 600px;
  border:2px solid #fff;
  box-shadow: 6px 6px 2px #ccc;
  -moz-box-shadow: 6px 6px 2px #ccc;
  -webkit-box-shadow: 6px 6px 2px #ccc;
  -khtml-box-shadow: 6px 6px 2px #ccc;
  margin-bottom: 40px;
}
</style>

<figure>
  <img class="img" src="../../../images/dollar-gill-0V7_N62zZcU-unsplash.jpg" border="0" alt="A mysterious book on a table with a glowing globe" width="600"/>
  <figcaption>
    Photo by <a href="https://unsplash.com/@dollargill?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Dollar Gill</a> on <a href="https://unsplash.com/s/photos/magic?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a>
  <figcaption>
</figure>

<div id="outline-container-orgc153bc3" class="outline-2">
<h2 id="orgc153bc3">Introduction</h2>
<div class="outline-text-2" id="text-orgc153bc3">
<p>
As the <a href="https://docs.scala-lang.org/scala3/book/taste-collections.html">Scala 3 - book</a> points out, Scala has a rich set of collection
classes. As well as <code>List</code> it also has a solid implementation of <code>LazyList</code>. If you're not sure what that is, or what is used for, read on and find out, plus even better I will walk through a full implementation of LazyList that can do some magical things.
</p>

<p>
Scala <code>List</code> can represent collections of <code>zero or more</code>, stored as a linked list, with the details of the underlying data structure abstracted away. 
In my video <a href="https://youtu.be/7A2xuRkCZBg">NonEmptyLists more or less</a> I talked about how
we can build a variant of <code>List</code> that can only be a collection with <code>one or more</code> items. 
</p>

<p>
In this video I will present theory and practise of building a <code>LazyList</code> type, that adds the additional capability of controlling <code>when elements are evaluated</code>.
</p>

<p>
All the code written in this post, and accompanying video <a href="https://youtu.be/laB15gG5bjY">The Magic of Lazy Lists</a> can be found in my new pedagogical Scala library <a href="https://github.com/justinhj/duct/">Duct</a>. In order to produce this implementation I studied the code of the 
Scala standard library (both the current version and history versions which are less sophisticated but also easier to read), as well as other implementations
such as that of the ScalaZ Ephemeral list. The resulting code is a combination of these with some of the best parts of both.
</p>
</div>
</div>

<div id="outline-container-org59f4441" class="outline-2">
<h2 id="org59f4441">Implementing Lazy Thing</h2>
<div class="outline-text-2" id="text-org59f4441">
<p>
<code>LazyList</code> is easier to understand if you have a good grasp for different evaluation models in Scala, so let's explore that with a custom class call <code>LazyThing</code>.
</p>

<p>
With this implementation LazyThing is just a wrapper of values, with a get function that returns the value. This is what we call eager or strict evaluation. When I pass 
the expression <code>{println("evaluated"); 10</code> is passed into the <code>LazyThing</code> constructor it is evaluated immediately and stored in the class. We see it prints evaluated
and then when the user gets the value nothing is printed, we just get the result.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">LazyThing</span>[<span style="color: #00bcff;">A</span>](a<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">A</span>)<span style="color: #b6a0ff;">:</span>
   <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">get</span> <span style="color: #b6a0ff;">=</span> a

<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">lt</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">new</span> <span style="color: #6ae4b9;">LazyThing</span>({println(<span style="color: #79a8ff;">"evaluated"</span>); <span style="color: #00bcff;">10</span>})
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">evaluated</span>
lt.get
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">val res4: Int = 10</span>
</pre>
</div>

<p>
When working with a <code>LazyList</code> we want to be able to populate it with expressions but without having them evaluated until we are ready (what Haskell refers to
as call by need). What else can we use in Scala that only evaluates when we want it to? Functions! If the argument was a function, we could simply
call it when the user calls get, making it lazy.
</p>

<p>
Now when we create the class nothing is evaluated until we call get, and then it is evaluated every time. This evaluation mode is called <code>always</code>.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">LazyThing</span>[<span style="color: #00bcff;">A</span>](a<span style="color: #b6a0ff;">:</span> () <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">A</span>)<span style="color: #b6a0ff;">:</span>
   <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">get</span> <span style="color: #b6a0ff;">=</span> a()

<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">lt</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">new</span> <span style="color: #6ae4b9;">LazyThing</span>(() <span style="color: #b6a0ff;">=&gt;</span> {println(<span style="color: #79a8ff;">"evaluated"</span>); <span style="color: #00bcff;">10</span>})

<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">scala&gt; lt.get</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">evaluated</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">val res15: Int = 10</span>

<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">scala&gt; lt.get</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">evaluated</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">val res16: Int = 10</span>
</pre>
</div>

<p>
The <code>LazyList</code> structure is not about always evaluation though, it is about <code>lazy</code> or <code>by need</code> evaluation. We want to be able to remember the result 
of evaluated list elements, and never evaluate them again. This <code>memoization</code> is the next step.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">LazyThing</span>[<span style="color: #00bcff;">A</span>](a<span style="color: #b6a0ff;">:</span> () <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">A</span>)<span style="color: #b6a0ff;">:</span>
   <span style="color: #b6a0ff;">var</span> <span style="color: #dbbe5f;">evaluated</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">false</span>
   <span style="color: #b6a0ff;">var</span> <span style="color: #dbbe5f;">value</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">A</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">_</span>
   <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">get</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">if</span> evaluated then value
     <span style="color: #b6a0ff;">else</span>
         evaluated <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">true</span>
         value <span style="color: #b6a0ff;">=</span> a()

<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">lt</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">new</span> <span style="color: #6ae4b9;">LazyThing</span>(() <span style="color: #b6a0ff;">=&gt;</span> {println(<span style="color: #79a8ff;">"evaluated"</span>); <span style="color: #00bcff;">10</span>})

<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">scala&gt; lt.get</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">evaluated</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">val res17: Any = ()</span>

<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">scala&gt; lt.get</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">val res18: Any = 10</span>
</pre>
</div>

<p>
Now you can see that the value is evaluated only once and we can retrieve it multiple times. Memoization is good because it saves us recomputing 
values, but it also means we must be mindful of memory use and hanging on to references to the internal structure of our <code>LazyList</code> so as not 
to consume memory that is no loger needed.
</p>

<p>
Two final simplifications using Scala features make this much more succinct. The mechanism of passing an argument as a function executed only on first 
reference is implemented within Scala and known as call by name. Rewriting like below uses that mechanism instead.
</p>

<p>
Secondly, we can replace the manual memoization code that remembers the evaluated value with <code>lazy val</code> which does the same thing but, again, is built into the compiler.
</p>


<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">LazyThing</span>[<span style="color: #00bcff;">A</span>](a<span style="color: #b6a0ff;">:</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">A</span>)<span style="color: #b6a0ff;">:</span>
  <span style="color: #f78fe7;">lazy</span> <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">get</span> <span style="color: #b6a0ff;">=</span> a

<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">lt</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">new</span> <span style="color: #6ae4b9;">LazyThing</span>({println(<span style="color: #79a8ff;">"evaluated"</span>); <span style="color: #00bcff;">10</span>})
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">scala&gt; lt.get</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">evaluated</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">val res24: Int = 10</span>

<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">scala&gt; lt.get</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">val res25: Int = 10</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgdbc13d7" class="outline-2">
<h2 id="orgdbc13d7">Beginning LazyList</h2>
</div>
