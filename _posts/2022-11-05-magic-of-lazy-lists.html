---
layout: post
title: The Magic of Lazy Lists
tags: [pure-functional-programming, cats, scala, applicative, monads, comonads, kleisli, zio]
---
<link rel="stylesheet" type="text/css" href="../../../_orgcss/site.css" />

<style>
.img {
  width: 600px;
  border:2px solid #fff;
  box-shadow: 6px 6px 2px #ccc;
  -moz-box-shadow: 6px 6px 2px #ccc;
  -webkit-box-shadow: 6px 6px 2px #ccc;
  -khtml-box-shadow: 6px 6px 2px #ccc;
  margin-bottom: 40px;
}
</style>

<figure>
  <img class="img" src="../../../images/dollar-gill-0V7_N62zZcU-unsplash.jpg" border="0" alt="A mysterious book on a table with a glowing globe" width="600"/>
  <figcaption>
    Photo by <a href="https://unsplash.com/@dollargill?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Dollar Gill</a> on <a href="https://unsplash.com/s/photos/magic?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a>
  <figcaption>
</figure>

<div id="outline-container-orgc153bc3" class="outline-2">
<h2 id="orgc153bc3">Introduction</h2>
<div class="outline-text-2" id="text-orgc153bc3">
<p>
As the <a href="https://docs.scala-lang.org/scala3/book/taste-collections.html">Scala 3 - book</a> points out, Scala has a rich set of collection
classes. As well as <code>List</code> it also has a solid implementation of <code>LazyList</code>. If you're not sure what that is, or what is used for, read on and find out, plus even better I will walk through a full implementation of LazyList that can do some magical things.
</p>

<p>
Scala <code>List</code> can represent collections of <code>zero or more</code>, stored as a linked list, with the details of the underlying data structure abstracted away. 
In my video <a href="https://youtu.be/7A2xuRkCZBg">NonEmptyLists more or less</a> I talked about how
we can build a variant of <code>List</code> that can only be a collection with <code>one or more</code> items. 
</p>

<p>
In this video I will present theory and practise of building a <code>LazyList</code> type, that adds the additional capability of controlling <code>when elements are evaluated</code>.
</p>

<p>
All the code written in this post, and accompanying video <a href="https://youtu.be/laB15gG5bjY">The Magic of Lazy Lists</a> can be found in my new pedagogical Scala library <a href="https://github.com/justinhj/duct/">Duct</a>. In order to produce this implementation I studied the code of the 
Scala standard library (both the current version and history versions which are less sophisticated but also easier to read), as well as other implementations
such as that of the ScalaZ Ephemeral list. The resulting code is a combination of these with some of the best parts of both.
</p>
</div>
</div>

<div id="outline-container-org59f4441" class="outline-2">
<h2 id="org59f4441">Implementing Lazy Thing</h2>
<div class="outline-text-2" id="text-org59f4441">
<p>
<code>LazyList</code> is easier to understand if you have a good grasp for different evaluation models in Scala, so let's explore that with a custom class call <code>LazyThing</code>.
</p>

<p>
With this implementation LazyThing is just a wrapper of values, with a get function that returns the value. This is what we call eager or strict evaluation. When I pass 
the expression <code>{println("evaluated"); 10</code> is passed into the <code>LazyThing</code> constructor it is evaluated immediately and stored in the class. We see it prints evaluated
and then when the user gets the value nothing is printed, we just get the result.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">LazyThing</span>[<span style="color: #00bcff;">A</span>](a<span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">A</span>)<span style="color: #b6a0ff;">:</span>
   <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">get</span> <span style="color: #b6a0ff;">=</span> a

<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">lt</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">new</span> <span style="color: #6ae4b9;">LazyThing</span>({println(<span style="color: #79a8ff;">"evaluated"</span>); <span style="color: #00bcff;">10</span>})
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">evaluated</span>
lt.get
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">val res4: Int = 10</span>
</pre>
</div>

<p>
When working with a <code>LazyList</code> we want to be able to populate it with expressions but without having them evaluated until we are ready (what Haskell refers to
as call by need). What else can we use in Scala that only evaluates when we want it to? Functions! If the argument was a function, we could simply
call it when the user calls get, making it lazy.
</p>

<p>
Now when we create the class nothing is evaluated until we call get, and then it is evaluated every time. This evaluation mode is called <code>always</code>.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">LazyThing</span>[<span style="color: #00bcff;">A</span>](a<span style="color: #b6a0ff;">:</span> () <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">A</span>)<span style="color: #b6a0ff;">:</span>
   <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">get</span> <span style="color: #b6a0ff;">=</span> a()

<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">lt</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">new</span> <span style="color: #6ae4b9;">LazyThing</span>(() <span style="color: #b6a0ff;">=&gt;</span> {println(<span style="color: #79a8ff;">"evaluated"</span>); <span style="color: #00bcff;">10</span>})

<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">scala&gt; lt.get</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">evaluated</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">val res15: Int = 10</span>

<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">scala&gt; lt.get</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">evaluated</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">val res16: Int = 10</span>
</pre>
</div>

<p>
The <code>LazyList</code> structure is not about always evaluation though, it is about <code>lazy</code> or <code>by need</code> evaluation. We want to be able to remember the result 
of evaluated list elements, and never evaluate them again. This <code>memoization</code> is the next step.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">LazyThing</span>[<span style="color: #00bcff;">A</span>](a<span style="color: #b6a0ff;">:</span> () <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">A</span>)<span style="color: #b6a0ff;">:</span>
   <span style="color: #b6a0ff;">var</span> <span style="color: #dbbe5f;">evaluated</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">false</span>
   <span style="color: #b6a0ff;">var</span> <span style="color: #dbbe5f;">value</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">A</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">_</span>
   <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">get</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">if</span> evaluated then value
     <span style="color: #b6a0ff;">else</span>
         evaluated <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">true</span>
         value <span style="color: #b6a0ff;">=</span> a()

<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">lt</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">new</span> <span style="color: #6ae4b9;">LazyThing</span>(() <span style="color: #b6a0ff;">=&gt;</span> {println(<span style="color: #79a8ff;">"evaluated"</span>); <span style="color: #00bcff;">10</span>})

<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">scala&gt; lt.get</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">evaluated</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">val res17: Any = ()</span>

<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">scala&gt; lt.get</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">val res18: Any = 10</span>
</pre>
</div>

<p>
Now you can see that the value is evaluated only once and we can retrieve it multiple times. Memoization is good because it saves us recomputing 
values, but it also means we must be mindful of memory use and hanging on to references to the internal structure of our <code>LazyList</code> so as not 
to consume memory that is no loger needed.
</p>

<p>
Two final simplifications using Scala features make this much more succinct. The mechanism of passing an argument as a function executed only on first 
reference is implemented within Scala and known as call by name. Rewriting like below uses that mechanism instead.
</p>

<p>
Secondly, we can replace the manual memoization code that remembers the evaluated value with <code>lazy val</code> which does the same thing but, again, is built into the compiler.
</p>


<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">class</span> <span style="color: #6ae4b9;">LazyThing</span>[<span style="color: #00bcff;">A</span>](a<span style="color: #b6a0ff;">:</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">A</span>)<span style="color: #b6a0ff;">:</span>
  <span style="color: #f78fe7;">lazy</span> <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">get</span> <span style="color: #b6a0ff;">=</span> a

<span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">lt</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">new</span> <span style="color: #6ae4b9;">LazyThing</span>({println(<span style="color: #79a8ff;">"evaluated"</span>); <span style="color: #00bcff;">10</span>})
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">scala&gt; lt.get</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">evaluated</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">val res24: Int = 10</span>

<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">scala&gt; lt.get</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">val res25: Int = 10</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgdbc13d7" class="outline-2">
<h2 id="orgdbc13d7">Beginning LazyList</h2>
<div class="outline-text-2" id="text-orgdbc13d7">
<p>
Let's begin by representing the <code>LazyList</code> as a sealed trait, which will be the object through which users interact with the collection.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #f78fe7;">sealed</span> <span style="color: #b6a0ff;">trait</span> <span style="color: #6ae4b9;">LazyList</span>[+<span style="color: #00bcff;">A</span>]<span style="color: #b6a0ff;">:</span>
   <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">head</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">A</span>
   <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">tail</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">LazyList</span>[<span style="color: #00bcff;">A</span>]
   <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">isEmpty</span><span style="color: #b6a0ff;">:</span> <span style="color: #6ae4b9;">Boolean</span>
</pre>
</div>

<p>
Of note here is the <code>+A</code> variance notation. It's important to know about and understand variance when making libraries in Scala, slightly less
important when writing application code. A short explanation of variance is that it is short for "variance under inheritance".
</p>

<p>
Let's say we have a type <code>Loan</code> and two other sub types of Loan, <code>Credit Card</code> and <code>Amortized Loan</code>. If you have some function that takes Loan 
and prints the outstanding balance, you would expect through normal rules of inheritance to be able to pass in a Credit card or an amortized 
loan in place of the Loan. You can use a subtype of loan whereever the compiler is expecting a loan. That is what is known as behavioural 
subtyping. 
</p>

<p>
What variance under inheritance refers to, is what should we do when we have some parameterized type with respect to subtyping? If I have a function 
that takes a list of Loans, should it accept a list of subtypes? Credit cards for examples. Because the answer to this is, no not always, Scala 
includes variance annotations so that you can choose the variance relationship you want as needed. I'll come back to this topic in more detail in a later 
video.
</p>

<p>
<code>LazyList</code> will have a companion object containing all the static methods that will be used to create and manipulate lazy lists. The first thing 
we need is a representation of empty list. We add that to a new companion object.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">object</span> <span style="color: #00bcff;">LazyList</span><span style="color: #b6a0ff;">:</span>
  <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">empty</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">new</span> <span style="color: #6ae4b9;">LazyList</span>[<span style="color: #00bcff;">Nothing</span>]<span style="color: #b6a0ff;">:</span>
      <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">head</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">throw</span> <span style="color: #b6a0ff;">new</span> <span style="color: #6ae4b9;">NoSuchElementException</span>(<span style="color: #79a8ff;">"Cannot get head of empty lazy list"</span>)
      <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">tail</span> <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">throw</span> <span style="color: #b6a0ff;">new</span> <span style="color: #6ae4b9;">UnsupportedOperationException</span>(<span style="color: #79a8ff;">"No tail of empty lazy list"</span>)
      <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">isEmpty</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">true</span>
</pre>
</div>

<p>
Lazy list has the type Nothing. Nothing is at the bottom of Scala's type hierarchy meaning it is the subtype of everything. Now it's not a useful type
in itself, because you can't do anything with it, but it is really useful in this context&#x2026; our empty list is a singleton value shared by all lazy 
lists, we only need one. Why does this work? Because of the variance annotation above. We said that a list of subtypes of <code>A</code> would be acceptable as 
list of <code>A</code>. 
</p>

<p>
So now we are able to create lazy lists with nothing in them using <code>LazyList.empty</code>. The next step is to be able to create lists with elements inside. We will call this the <code>cons</code> method, 
as it will be used to construct lists one lazy element at a time.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">object LazyList continued:</span>
  <span style="color: #b6a0ff;">def</span> <span style="color: #feacd0;">cons</span>[<span style="color: #00bcff;">A</span>](hd<span style="color: #b6a0ff;">:</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">A</span>, tl<span style="color: #b6a0ff;">:</span> <span style="color: #b6a0ff;">=&gt;</span> <span style="color: #00bcff;">LazyList</span>[<span style="color: #00bcff;">A</span>]) <span style="color: #b6a0ff;">=</span> <span style="color: #b6a0ff;">new</span> <span style="color: #6ae4b9;">LazyList</span>[<span style="color: #00bcff;">A</span>]<span style="color: #b6a0ff;">:</span>
    <span style="color: #f78fe7;">lazy</span> <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">head</span> <span style="color: #b6a0ff;">=</span> hd
    <span style="color: #f78fe7;">lazy</span> <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">tail</span> <span style="color: #b6a0ff;">=</span> tl
    <span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">isEmpty</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">false</span>
</pre>
</div>

<p>
With this small amount of code we have a functional (no pun intended) lazy list.
</p>

<div class="org-src-container">
<pre class="src src-scala"><span style="color: #b6a0ff;">val</span> <span style="color: #00d3d0;">ll</span> <span style="color: #b6a0ff;">=</span> <span style="color: #00bcff;">LazyList</span>.cons({println(<span style="color: #79a8ff;">"evaluated!"</span>);<span style="color: #00bcff;">10</span>}, <span style="color: #00bcff;">LazyList</span>.empty)
ll.head
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">evaluated!</span>
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">val res9: Int = 10</span>

ll.head
<span style="color: #a8a8a8;">// </span><span style="color: #a8a8a8;">val res10: Int = 10</span>
</pre>
</div>

<p>
Here you can see that constructing the list did not evaluate the value we passed in to be the head of the collection. Once we retrieved the head we got the 
evaluation happen, but subsequently we did not not. Nice.
</p>
</div>
</div>
